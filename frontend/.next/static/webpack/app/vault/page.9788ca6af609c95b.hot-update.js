"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/vault/page",{

/***/ "(app-pages-browser)/./src/lib/crypto.ts":
/*!***************************!*\
  !*** ./src/lib/crypto.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculatePasswordEntropy: function() { return /* binding */ calculatePasswordEntropy; },\n/* harmony export */   decryptVaultItem: function() { return /* binding */ decryptVaultItem; },\n/* harmony export */   encryptVaultItem: function() { return /* binding */ encryptVaultItem; },\n/* harmony export */   estimateTimeToCrack: function() { return /* binding */ estimateTimeToCrack; },\n/* harmony export */   exportVaultData: function() { return /* binding */ exportVaultData; },\n/* harmony export */   generateRandomKey: function() { return /* binding */ generateRandomKey; },\n/* harmony export */   generateSecureId: function() { return /* binding */ generateSecureId; },\n/* harmony export */   generateSecurePassword: function() { return /* binding */ generateSecurePassword; },\n/* harmony export */   hashPassword: function() { return /* binding */ hashPassword; },\n/* harmony export */   importVaultData: function() { return /* binding */ importVaultData; },\n/* harmony export */   isCryptoAvailable: function() { return /* binding */ isCryptoAvailable; },\n/* harmony export */   validatePasswordStrength: function() { return /* binding */ validatePasswordStrength; }\n/* harmony export */ });\n// frontend/src/lib/crypto.ts\n/**\r\n * Client-side encryption using Web Crypto API\r\n * \r\n * Encryption Strategy:\r\n * - AES-GCM 256-bit encryption for vault data\r\n * - PBKDF2 with 100,000 iterations for key derivation\r\n * - Random salt and IV for each encryption operation\r\n * - Zero-knowledge architecture: server never sees plaintext\r\n */ /**\r\n * Derive encryption key from master password using PBKDF2\r\n */ async function deriveKey(masterPassword, salt) {\n    const encoder = new TextEncoder();\n    // Import the master password as key material\n    const keyMaterial = await crypto.subtle.importKey(\"raw\", encoder.encode(masterPassword), \"PBKDF2\", false, [\n        \"deriveBits\",\n        \"deriveKey\"\n    ]);\n    // Derive AES-GCM key using PBKDF2\n    return crypto.subtle.deriveKey({\n        name: \"PBKDF2\",\n        // cast to BufferSource to satisfy TypeScript lib differences\n        salt: salt,\n        iterations: 100000,\n        hash: \"SHA-256\"\n    }, keyMaterial, {\n        name: \"AES-GCM\",\n        length: 256\n    }, true, [\n        \"encrypt\",\n        \"decrypt\"\n    ]);\n}\n/**\r\n * Encrypt vault item data\r\n */ async function encryptVaultItem(data, masterPassword) {\n    const encoder = new TextEncoder();\n    // Generate random salt and IV\n    const salt = crypto.getRandomValues(new Uint8Array(16));\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    // Derive encryption key\n    const key = await deriveKey(masterPassword, salt);\n    // Encrypt the data\n    const encrypted = await crypto.subtle.encrypt({\n        name: \"AES-GCM\",\n        iv: iv\n    }, key, encoder.encode(JSON.stringify(data)));\n    // Convert to base64 for storage\n    return {\n        encrypted: arrayBufferToBase64(encrypted),\n        salt: arrayBufferToBase64(salt),\n        iv: arrayBufferToBase64(iv)\n    };\n}\n/**\r\n * Decrypt vault item data\r\n */ async function decryptVaultItem(encryptedData, masterPassword) {\n    const decoder = new TextDecoder();\n    // Convert from base64\n    const salt = base64ToArrayBuffer(encryptedData.salt);\n    const iv = base64ToArrayBuffer(encryptedData.iv);\n    const encrypted = base64ToArrayBuffer(encryptedData.encrypted);\n    // Derive decryption key\n    const key = await deriveKey(masterPassword, salt);\n    // Decrypt the data\n    const decrypted = await crypto.subtle.decrypt({\n        name: \"AES-GCM\",\n        iv: iv\n    }, key, encrypted);\n    // Parse and return the data\n    return JSON.parse(decoder.decode(decrypted));\n}\nfunction generateSecurePassword(options) {\n    const lowercase = \"abcdefghijklmnopqrstuvwxyz\";\n    const uppercase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    const numbers = \"0123456789\";\n    const symbols = \"!@#$%^&*()_+-=[]{}|;:,.<>?\";\n    const ambiguous = \"il1Lo0O\";\n    // Build character set\n    let charset = lowercase + uppercase;\n    if (options.includeNumbers) charset += numbers;\n    if (options.includeSymbols) charset += symbols;\n    // Remove ambiguous characters if requested\n    if (options.excludeAmbiguous) {\n        charset = charset.split(\"\").filter((c)=>!ambiguous.includes(c)).join(\"\");\n    }\n    // Generate password using crypto.getRandomValues for security\n    let password = \"\";\n    const randomValues = new Uint32Array(options.length);\n    crypto.getRandomValues(randomValues);\n    for(let i = 0; i < options.length; i++){\n        password += charset[randomValues[i] % charset.length];\n    }\n    return password;\n}\n/**\r\n * Hash password for authentication (client-side pre-hash)\r\n * Note: This is NOT for vault encryption, only for auth\r\n */ async function hashPassword(password) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(password);\n    const hash = await crypto.subtle.digest(\"SHA-256\", data);\n    return arrayBufferToBase64(hash);\n}\n/**\r\n * Validate master password strength\r\n */ function validatePasswordStrength(password) {\n    const errors = [];\n    if (password.length < 12) {\n        errors.push(\"Password must be at least 12 characters long\");\n    }\n    if (!/[a-z]/.test(password)) {\n        errors.push(\"Password must contain lowercase letters\");\n    }\n    if (!/[A-Z]/.test(password)) {\n        errors.push(\"Password must contain uppercase letters\");\n    }\n    if (!/[0-9]/.test(password)) {\n        errors.push(\"Password must contain numbers\");\n    }\n    if (!/[^a-zA-Z0-9]/.test(password)) {\n        errors.push(\"Password must contain special characters\");\n    }\n    return {\n        isValid: errors.length === 0,\n        errors\n    };\n}\n/**\r\n * Utility function: Convert ArrayBuffer to Base64 string\r\n */ function arrayBufferToBase64(buffer) {\n    // Normalize to Uint8Array view\n    const bytes = buffer instanceof ArrayBuffer ? new Uint8Array(buffer) : new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    let binary = \"\";\n    const chunkSize = 0x8000; // safe chunk to avoid call stack issues\n    for(let i = 0; i < bytes.length; i += chunkSize){\n        const chunk = bytes.subarray(i, i + chunkSize);\n        binary += String.fromCharCode.apply(null, Array.from(chunk));\n    }\n    return btoa(binary);\n}\n/**\r\n * Utility function: Convert Base64 string to Uint8Array\r\n */ function base64ToArrayBuffer(base64) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for(let i = 0; i < binary.length; i++){\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n/**\r\n * Generate a random encryption key (for testing/demo purposes)\r\n */ async function generateRandomKey() {\n    return crypto.subtle.generateKey({\n        name: \"AES-GCM\",\n        length: 256\n    }, true, [\n        \"encrypt\",\n        \"decrypt\"\n    ]);\n}\n/**\r\n * Calculate password entropy (bits of randomness)\r\n */ function calculatePasswordEntropy(password) {\n    let charsetSize = 0;\n    if (/[a-z]/.test(password)) charsetSize += 26;\n    if (/[A-Z]/.test(password)) charsetSize += 26;\n    if (/[0-9]/.test(password)) charsetSize += 10;\n    if (/[^a-zA-Z0-9]/.test(password)) charsetSize += 32; // Approximate\n    return Math.log2(Math.pow(charsetSize, password.length));\n}\n/**\r\n * Estimate time to crack password (in years)\r\n */ function estimateTimeToCrack(password) {\n    const entropy = calculatePasswordEntropy(password);\n    const guessesPerSecond = 1e9; // 1 billion guesses per second\n    const secondsToCrack = Math.pow(2, entropy) / guessesPerSecond;\n    const yearsToCrack = secondsToCrack / (365.25 * 24 * 60 * 60);\n    let timeToCrack;\n    let strength;\n    if (yearsToCrack < 0.001) {\n        timeToCrack = \"Instantly\";\n        strength = \"Very Weak\";\n    } else if (yearsToCrack < 1) {\n        timeToCrack = \"\".concat(Math.round(yearsToCrack * 365), \" days\");\n        strength = \"Weak\";\n    } else if (yearsToCrack < 1000) {\n        timeToCrack = \"\".concat(Math.round(yearsToCrack), \" years\");\n        strength = \"Moderate\";\n    } else if (yearsToCrack < 1000000) {\n        timeToCrack = \"\".concat(Math.round(yearsToCrack / 1000), \"K years\");\n        strength = \"Strong\";\n    } else {\n        timeToCrack = \"\".concat(Math.round(yearsToCrack / 1000000), \"M years\");\n        strength = \"Very Strong\";\n    }\n    return {\n        entropy: Math.round(entropy),\n        timeToCrack,\n        strength\n    };\n}\n/**\r\n * Export vault data (encrypted)\r\n */ async function exportVaultData(items, masterPassword) {\n    const exportData = {\n        version: 1,\n        timestamp: new Date().toISOString(),\n        items: await Promise.all(items.map((item)=>encryptVaultItem(item, masterPassword)))\n    };\n    return JSON.stringify(exportData, null, 2);\n}\n/**\r\n * Import vault data (decrypt)\r\n */ async function importVaultData(exportedData, masterPassword) {\n    try {\n        const data = JSON.parse(exportedData);\n        if (!data.version || !data.items) {\n            throw new Error(\"Invalid export file format\");\n        }\n        const items = await Promise.all(data.items.map((encryptedItem)=>decryptVaultItem(encryptedItem, masterPassword)));\n        return items;\n    } catch (error) {\n        throw new Error(\"Failed to import vault data. Check your master password.\");\n    }\n}\n/**\r\n * Check if Web Crypto API is available\r\n */ function isCryptoAvailable() {\n    return  true && typeof window.crypto !== \"undefined\" && typeof window.crypto.subtle !== \"undefined\";\n}\n/**\r\n * Generate a secure random ID\r\n */ function generateSecureId() {\n    let length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;\n    const array = new Uint8Array(length);\n    crypto.getRandomValues(array);\n    return Array.from(array, (byte)=>byte.toString(16).padStart(2, \"0\")).join(\"\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxPQUFRMUYsaUJBQWlCMEYsTUFBTXZHO0lBRTdDO0lBRUEsT0FBT3FCLEtBQUtDLFNBQVMsQ0FBQ3lFLFlBQVksTUFBTTtBQUMxQztBQUVBOztDQUVDLEdBQ00sZUFBZVMsZ0JBQ3BCQyxZQUFvQixFQUNwQnpHLGNBQXNCO0lBRXRCLElBQUk7UUFDRixNQUFNYyxPQUFPTyxLQUFLVSxLQUFLLENBQUMwRTtRQUV4QixJQUFJLENBQUMzRixLQUFLa0YsT0FBTyxJQUFJLENBQUNsRixLQUFLZ0YsS0FBSyxFQUFFO1lBQ2hDLE1BQU0sSUFBSVksTUFBTTtRQUNsQjtRQUVBLE1BQU1aLFFBQVEsTUFBTU0sUUFBUUMsR0FBRyxDQUM3QnZGLEtBQUtnRixLQUFLLENBQUNRLEdBQUcsQ0FBQyxDQUFDSyxnQkFDZG5GLGlCQUFpQm1GLGVBQWUzRztRQUlwQyxPQUFPOEY7SUFDVCxFQUFFLE9BQU9jLE9BQU87UUFDZCxNQUFNLElBQUlGLE1BQU07SUFDbEI7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU0c7SUFDZCxPQUFPLEtBQWtCLElBQ2xCLE9BQU9DLE9BQU96RyxNQUFNLEtBQUssZUFDekIsT0FBT3lHLE9BQU96RyxNQUFNLENBQUNDLE1BQU0sS0FBSztBQUN6QztBQUVBOztDQUVDLEdBQ00sU0FBU3lHO1FBQWlCbkcsU0FBQUEsaUVBQWlCO0lBQ2hELE1BQU1vRyxRQUFRLElBQUloRyxXQUFXSjtJQUM3QlAsT0FBT1UsZUFBZSxDQUFDaUc7SUFDdkIsT0FBT3hDLE1BQU1DLElBQUksQ0FBQ3VDLE9BQU9DLENBQUFBLE9BQVFBLEtBQUtDLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRyxNQUFNbkUsSUFBSSxDQUFDO0FBQzVFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvY3J5cHRvLnRzPzUwYmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnJvbnRlbmQvc3JjL2xpYi9jcnlwdG8udHNcclxuXHJcbi8qKlxyXG4gKiBDbGllbnQtc2lkZSBlbmNyeXB0aW9uIHVzaW5nIFdlYiBDcnlwdG8gQVBJXHJcbiAqIFxyXG4gKiBFbmNyeXB0aW9uIFN0cmF0ZWd5OlxyXG4gKiAtIEFFUy1HQ00gMjU2LWJpdCBlbmNyeXB0aW9uIGZvciB2YXVsdCBkYXRhXHJcbiAqIC0gUEJLREYyIHdpdGggMTAwLDAwMCBpdGVyYXRpb25zIGZvciBrZXkgZGVyaXZhdGlvblxyXG4gKiAtIFJhbmRvbSBzYWx0IGFuZCBJViBmb3IgZWFjaCBlbmNyeXB0aW9uIG9wZXJhdGlvblxyXG4gKiAtIFplcm8ta25vd2xlZGdlIGFyY2hpdGVjdHVyZTogc2VydmVyIG5ldmVyIHNlZXMgcGxhaW50ZXh0XHJcbiAqL1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFbmNyeXB0ZWREYXRhIHtcclxuICBlbmNyeXB0ZWQ6IHN0cmluZzsgIC8vIEJhc2U2NCBlbmNvZGVkIGVuY3J5cHRlZCBkYXRhXHJcbiAgc2FsdDogc3RyaW5nOyAgICAgICAvLyBCYXNlNjQgZW5jb2RlZCBzYWx0XHJcbiAgaXY6IHN0cmluZzsgICAgICAgICAvLyBCYXNlNjQgZW5jb2RlZCBpbml0aWFsaXphdGlvbiB2ZWN0b3JcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBWYXVsdEl0ZW0ge1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgdXNlcm5hbWU6IHN0cmluZztcclxuICBwYXNzd29yZDogc3RyaW5nO1xyXG4gIHVybDogc3RyaW5nO1xyXG4gIG5vdGVzOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXJpdmUgZW5jcnlwdGlvbiBrZXkgZnJvbSBtYXN0ZXIgcGFzc3dvcmQgdXNpbmcgUEJLREYyXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZXJpdmVLZXkoXHJcbiAgbWFzdGVyUGFzc3dvcmQ6IHN0cmluZyxcclxuICBzYWx0OiBCdWZmZXJTb3VyY2VcclxuKTogUHJvbWlzZTxDcnlwdG9LZXk+IHtcclxuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XHJcbiAgXHJcbiAgLy8gSW1wb3J0IHRoZSBtYXN0ZXIgcGFzc3dvcmQgYXMga2V5IG1hdGVyaWFsXHJcbiAgY29uc3Qga2V5TWF0ZXJpYWwgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcclxuICAgICdyYXcnLFxyXG4gICAgZW5jb2Rlci5lbmNvZGUobWFzdGVyUGFzc3dvcmQpLFxyXG4gICAgJ1BCS0RGMicsXHJcbiAgICBmYWxzZSxcclxuICAgIFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXVxyXG4gICk7XHJcbiAgXHJcbiAgLy8gRGVyaXZlIEFFUy1HQ00ga2V5IHVzaW5nIFBCS0RGMlxyXG4gIHJldHVybiBjcnlwdG8uc3VidGxlLmRlcml2ZUtleShcclxuICAgIHtcclxuICAgICAgbmFtZTogJ1BCS0RGMicsXHJcbiAgICAgIC8vIGNhc3QgdG8gQnVmZmVyU291cmNlIHRvIHNhdGlzZnkgVHlwZVNjcmlwdCBsaWIgZGlmZmVyZW5jZXNcclxuICAgICAgc2FsdDogc2FsdCBhcyB1bmtub3duIGFzIEJ1ZmZlclNvdXJjZSxcclxuICAgICAgaXRlcmF0aW9uczogMTAwMDAwLCAgLy8gSGlnaCBpdGVyYXRpb24gY291bnQgZm9yIHNlY3VyaXR5XHJcbiAgICAgIGhhc2g6ICdTSEEtMjU2J1xyXG4gICAgfSxcclxuICAgIGtleU1hdGVyaWFsLFxyXG4gICAgeyBuYW1lOiAnQUVTLUdDTScsIGxlbmd0aDogMjU2IH0sXHJcbiAgICB0cnVlLFxyXG4gICAgWydlbmNyeXB0JywgJ2RlY3J5cHQnXVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmNyeXB0IHZhdWx0IGl0ZW0gZGF0YVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRWYXVsdEl0ZW0oXHJcbiAgZGF0YTogVmF1bHRJdGVtLFxyXG4gIG1hc3RlclBhc3N3b3JkOiBzdHJpbmdcclxuKTogUHJvbWlzZTxFbmNyeXB0ZWREYXRhPiB7XHJcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xyXG4gIFxyXG4gIC8vIEdlbmVyYXRlIHJhbmRvbSBzYWx0IGFuZCBJVlxyXG4gIGNvbnN0IHNhbHQgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDE2KSk7XHJcbiAgY29uc3QgaXYgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDEyKSk7XHJcbiAgXHJcbiAgLy8gRGVyaXZlIGVuY3J5cHRpb24ga2V5XHJcbiAgY29uc3Qga2V5ID0gYXdhaXQgZGVyaXZlS2V5KG1hc3RlclBhc3N3b3JkLCBzYWx0KTtcclxuICBcclxuICAvLyBFbmNyeXB0IHRoZSBkYXRhXHJcbiAgY29uc3QgZW5jcnlwdGVkID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5lbmNyeXB0KFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAnQUVTLUdDTScsXHJcbiAgICAgIGl2OiBpdiBhcyB1bmtub3duIGFzIEJ1ZmZlclNvdXJjZVxyXG4gICAgfSxcclxuICAgIGtleSxcclxuICAgIGVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KGRhdGEpKVxyXG4gICk7XHJcbiAgXHJcbiAgLy8gQ29udmVydCB0byBiYXNlNjQgZm9yIHN0b3JhZ2VcclxuICByZXR1cm4ge1xyXG4gICAgZW5jcnlwdGVkOiBhcnJheUJ1ZmZlclRvQmFzZTY0KGVuY3J5cHRlZCksXHJcbiAgICBzYWx0OiBhcnJheUJ1ZmZlclRvQmFzZTY0KHNhbHQpLFxyXG4gICAgaXY6IGFycmF5QnVmZmVyVG9CYXNlNjQoaXYpXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERlY3J5cHQgdmF1bHQgaXRlbSBkYXRhXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVjcnlwdFZhdWx0SXRlbShcclxuICBlbmNyeXB0ZWREYXRhOiBFbmNyeXB0ZWREYXRhLFxyXG4gIG1hc3RlclBhc3N3b3JkOiBzdHJpbmdcclxuKTogUHJvbWlzZTxWYXVsdEl0ZW0+IHtcclxuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XHJcbiAgXHJcbiAgLy8gQ29udmVydCBmcm9tIGJhc2U2NFxyXG4gIGNvbnN0IHNhbHQgPSBiYXNlNjRUb0FycmF5QnVmZmVyKGVuY3J5cHRlZERhdGEuc2FsdCk7XHJcbiAgY29uc3QgaXYgPSBiYXNlNjRUb0FycmF5QnVmZmVyKGVuY3J5cHRlZERhdGEuaXYpO1xyXG4gIGNvbnN0IGVuY3J5cHRlZCA9IGJhc2U2NFRvQXJyYXlCdWZmZXIoZW5jcnlwdGVkRGF0YS5lbmNyeXB0ZWQpO1xyXG4gIFxyXG4gIC8vIERlcml2ZSBkZWNyeXB0aW9uIGtleVxyXG4gIGNvbnN0IGtleSA9IGF3YWl0IGRlcml2ZUtleShtYXN0ZXJQYXNzd29yZCwgc2FsdCBhcyB1bmtub3duIGFzIEJ1ZmZlclNvdXJjZSk7XHJcbiAgXHJcbiAgLy8gRGVjcnlwdCB0aGUgZGF0YVxyXG4gIGNvbnN0IGRlY3J5cHRlZCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGVjcnlwdChcclxuICAgIHtcclxuICAgICAgbmFtZTogJ0FFUy1HQ00nLFxyXG4gICAgICBpdjogaXYgYXMgdW5rbm93biBhcyBCdWZmZXJTb3VyY2VcclxuICAgIH0sXHJcbiAgICBrZXksXHJcbiAgICBlbmNyeXB0ZWQgYXMgdW5rbm93biBhcyBCdWZmZXJTb3VyY2VcclxuICApO1xyXG4gIFxyXG4gIC8vIFBhcnNlIGFuZCByZXR1cm4gdGhlIGRhdGFcclxuICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVyLmRlY29kZShkZWNyeXB0ZWQpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSByYW5kb20gcGFzc3dvcmRcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGFzc3dvcmRPcHRpb25zIHtcclxuICBsZW5ndGg6IG51bWJlcjtcclxuICBpbmNsdWRlTnVtYmVyczogYm9vbGVhbjtcclxuICBpbmNsdWRlU3ltYm9sczogYm9vbGVhbjtcclxuICBleGNsdWRlQW1iaWd1b3VzOiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTZWN1cmVQYXNzd29yZChvcHRpb25zOiBQYXNzd29yZE9wdGlvbnMpOiBzdHJpbmcge1xyXG4gIGNvbnN0IGxvd2VyY2FzZSA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eic7XHJcbiAgY29uc3QgdXBwZXJjYXNlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJztcclxuICBjb25zdCBudW1iZXJzID0gJzAxMjM0NTY3ODknO1xyXG4gIGNvbnN0IHN5bWJvbHMgPSAnIUAjJCVeJiooKV8rLT1bXXt9fDs6LC48Pj8nO1xyXG4gIGNvbnN0IGFtYmlndW91cyA9ICdpbDFMbzBPJztcclxuICBcclxuICAvLyBCdWlsZCBjaGFyYWN0ZXIgc2V0XHJcbiAgbGV0IGNoYXJzZXQgPSBsb3dlcmNhc2UgKyB1cHBlcmNhc2U7XHJcbiAgaWYgKG9wdGlvbnMuaW5jbHVkZU51bWJlcnMpIGNoYXJzZXQgKz0gbnVtYmVycztcclxuICBpZiAob3B0aW9ucy5pbmNsdWRlU3ltYm9scykgY2hhcnNldCArPSBzeW1ib2xzO1xyXG4gIFxyXG4gIC8vIFJlbW92ZSBhbWJpZ3VvdXMgY2hhcmFjdGVycyBpZiByZXF1ZXN0ZWRcclxuICBpZiAob3B0aW9ucy5leGNsdWRlQW1iaWd1b3VzKSB7XHJcbiAgICBjaGFyc2V0ID0gY2hhcnNldC5zcGxpdCgnJykuZmlsdGVyKGMgPT4gIWFtYmlndW91cy5pbmNsdWRlcyhjKSkuam9pbignJyk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEdlbmVyYXRlIHBhc3N3b3JkIHVzaW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgZm9yIHNlY3VyaXR5XHJcbiAgbGV0IHBhc3N3b3JkID0gJyc7XHJcbiAgY29uc3QgcmFuZG9tVmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KG9wdGlvbnMubGVuZ3RoKTtcclxuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJhbmRvbVZhbHVlcyk7XHJcbiAgXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBwYXNzd29yZCArPSBjaGFyc2V0W3JhbmRvbVZhbHVlc1tpXSAlIGNoYXJzZXQubGVuZ3RoXTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHBhc3N3b3JkO1xyXG59XHJcblxyXG4vKipcclxuICogSGFzaCBwYXNzd29yZCBmb3IgYXV0aGVudGljYXRpb24gKGNsaWVudC1zaWRlIHByZS1oYXNoKVxyXG4gKiBOb3RlOiBUaGlzIGlzIE5PVCBmb3IgdmF1bHQgZW5jcnlwdGlvbiwgb25seSBmb3IgYXV0aFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhc2hQYXNzd29yZChwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XHJcbiAgY29uc3QgZGF0YSA9IGVuY29kZXIuZW5jb2RlKHBhc3N3b3JkKTtcclxuICBjb25zdCBoYXNoID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBkYXRhKTtcclxuICByZXR1cm4gYXJyYXlCdWZmZXJUb0Jhc2U2NChoYXNoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlIG1hc3RlciBwYXNzd29yZCBzdHJlbmd0aFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUGFzc3dvcmRTdHJlbmd0aChwYXNzd29yZDogc3RyaW5nKToge1xyXG4gIGlzVmFsaWQ6IGJvb2xlYW47XHJcbiAgZXJyb3JzOiBzdHJpbmdbXTtcclxufSB7XHJcbiAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xyXG4gIFxyXG4gIGlmIChwYXNzd29yZC5sZW5ndGggPCAxMikge1xyXG4gICAgZXJyb3JzLnB1c2goJ1Bhc3N3b3JkIG11c3QgYmUgYXQgbGVhc3QgMTIgY2hhcmFjdGVycyBsb25nJyk7XHJcbiAgfVxyXG4gIGlmICghL1thLXpdLy50ZXN0KHBhc3N3b3JkKSkge1xyXG4gICAgZXJyb3JzLnB1c2goJ1Bhc3N3b3JkIG11c3QgY29udGFpbiBsb3dlcmNhc2UgbGV0dGVycycpO1xyXG4gIH1cclxuICBpZiAoIS9bQS1aXS8udGVzdChwYXNzd29yZCkpIHtcclxuICAgIGVycm9ycy5wdXNoKCdQYXNzd29yZCBtdXN0IGNvbnRhaW4gdXBwZXJjYXNlIGxldHRlcnMnKTtcclxuICB9XHJcbiAgaWYgKCEvWzAtOV0vLnRlc3QocGFzc3dvcmQpKSB7XHJcbiAgICBlcnJvcnMucHVzaCgnUGFzc3dvcmQgbXVzdCBjb250YWluIG51bWJlcnMnKTtcclxuICB9XHJcbiAgaWYgKCEvW15hLXpBLVowLTldLy50ZXN0KHBhc3N3b3JkKSkge1xyXG4gICAgZXJyb3JzLnB1c2goJ1Bhc3N3b3JkIG11c3QgY29udGFpbiBzcGVjaWFsIGNoYXJhY3RlcnMnKTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIGlzVmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXHJcbiAgICBlcnJvcnNcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogVXRpbGl0eSBmdW5jdGlvbjogQ29udmVydCBBcnJheUJ1ZmZlciB0byBCYXNlNjQgc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvQmFzZTY0KGJ1ZmZlcjogQXJyYXlCdWZmZXIgfCBBcnJheUJ1ZmZlclZpZXcpOiBzdHJpbmcge1xyXG4gIC8vIE5vcm1hbGl6ZSB0byBVaW50OEFycmF5IHZpZXdcclxuICBjb25zdCBieXRlcyA9IGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyXHJcbiAgICA/IG5ldyBVaW50OEFycmF5KGJ1ZmZlcilcclxuICAgIDogbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmJ1ZmZlciwgYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcclxuXHJcbiAgbGV0IGJpbmFyeSA9ICcnO1xyXG4gIGNvbnN0IGNodW5rU2l6ZSA9IDB4ODAwMDsgLy8gc2FmZSBjaHVuayB0byBhdm9pZCBjYWxsIHN0YWNrIGlzc3Vlc1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IGNodW5rU2l6ZSkge1xyXG4gICAgY29uc3QgY2h1bmsgPSBieXRlcy5zdWJhcnJheShpLCBpICsgY2h1bmtTaXplKTtcclxuICAgIGJpbmFyeSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIEFycmF5LmZyb20oY2h1bmspKTtcclxuICB9XHJcbiAgcmV0dXJuIGJ0b2EoYmluYXJ5KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb246IENvbnZlcnQgQmFzZTY0IHN0cmluZyB0byBVaW50OEFycmF5XHJcbiAqL1xyXG5mdW5jdGlvbiBiYXNlNjRUb0FycmF5QnVmZmVyKGJhc2U2NDogc3RyaW5nKTogVWludDhBcnJheSB7XHJcbiAgY29uc3QgYmluYXJ5ID0gYXRvYihiYXNlNjQpO1xyXG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5Lmxlbmd0aCk7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnkubGVuZ3RoOyBpKyspIHtcclxuICAgIGJ5dGVzW2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSk7XHJcbiAgfVxyXG4gIHJldHVybiBieXRlcztcclxufVxyXG4vKipcclxuICogR2VuZXJhdGUgYSByYW5kb20gZW5jcnlwdGlvbiBrZXkgKGZvciB0ZXN0aW5nL2RlbW8gcHVycG9zZXMpXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21LZXkoKTogUHJvbWlzZTxDcnlwdG9LZXk+IHtcclxuICByZXR1cm4gY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleShcclxuICAgIHtcclxuICAgICAgbmFtZTogJ0FFUy1HQ00nLFxyXG4gICAgICBsZW5ndGg6IDI1NlxyXG4gICAgfSxcclxuICAgIHRydWUsXHJcbiAgICBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBwYXNzd29yZCBlbnRyb3B5IChiaXRzIG9mIHJhbmRvbW5lc3MpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUGFzc3dvcmRFbnRyb3B5KHBhc3N3b3JkOiBzdHJpbmcpOiBudW1iZXIge1xyXG4gIGxldCBjaGFyc2V0U2l6ZSA9IDA7XHJcbiAgXHJcbiAgaWYgKC9bYS16XS8udGVzdChwYXNzd29yZCkpIGNoYXJzZXRTaXplICs9IDI2O1xyXG4gIGlmICgvW0EtWl0vLnRlc3QocGFzc3dvcmQpKSBjaGFyc2V0U2l6ZSArPSAyNjtcclxuICBpZiAoL1swLTldLy50ZXN0KHBhc3N3b3JkKSkgY2hhcnNldFNpemUgKz0gMTA7XHJcbiAgaWYgKC9bXmEtekEtWjAtOV0vLnRlc3QocGFzc3dvcmQpKSBjaGFyc2V0U2l6ZSArPSAzMjsgLy8gQXBwcm94aW1hdGVcclxuICBcclxuICByZXR1cm4gTWF0aC5sb2cyKE1hdGgucG93KGNoYXJzZXRTaXplLCBwYXNzd29yZC5sZW5ndGgpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVzdGltYXRlIHRpbWUgdG8gY3JhY2sgcGFzc3dvcmQgKGluIHllYXJzKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVzdGltYXRlVGltZVRvQ3JhY2socGFzc3dvcmQ6IHN0cmluZyk6IHtcclxuICBlbnRyb3B5OiBudW1iZXI7XHJcbiAgdGltZVRvQ3JhY2s6IHN0cmluZztcclxuICBzdHJlbmd0aDogJ1ZlcnkgV2VhaycgfCAnV2VhaycgfCAnTW9kZXJhdGUnIHwgJ1N0cm9uZycgfCAnVmVyeSBTdHJvbmcnO1xyXG59IHtcclxuICBjb25zdCBlbnRyb3B5ID0gY2FsY3VsYXRlUGFzc3dvcmRFbnRyb3B5KHBhc3N3b3JkKTtcclxuICBjb25zdCBndWVzc2VzUGVyU2Vjb25kID0gMWU5OyAvLyAxIGJpbGxpb24gZ3Vlc3NlcyBwZXIgc2Vjb25kXHJcbiAgY29uc3Qgc2Vjb25kc1RvQ3JhY2sgPSBNYXRoLnBvdygyLCBlbnRyb3B5KSAvIGd1ZXNzZXNQZXJTZWNvbmQ7XHJcbiAgY29uc3QgeWVhcnNUb0NyYWNrID0gc2Vjb25kc1RvQ3JhY2sgLyAoMzY1LjI1ICogMjQgKiA2MCAqIDYwKTtcclxuICBcclxuICBsZXQgdGltZVRvQ3JhY2s6IHN0cmluZztcclxuICBsZXQgc3RyZW5ndGg6ICdWZXJ5IFdlYWsnIHwgJ1dlYWsnIHwgJ01vZGVyYXRlJyB8ICdTdHJvbmcnIHwgJ1ZlcnkgU3Ryb25nJztcclxuICBcclxuICBpZiAoeWVhcnNUb0NyYWNrIDwgMC4wMDEpIHtcclxuICAgIHRpbWVUb0NyYWNrID0gJ0luc3RhbnRseSc7XHJcbiAgICBzdHJlbmd0aCA9ICdWZXJ5IFdlYWsnO1xyXG4gIH0gZWxzZSBpZiAoeWVhcnNUb0NyYWNrIDwgMSkge1xyXG4gICAgdGltZVRvQ3JhY2sgPSBgJHtNYXRoLnJvdW5kKHllYXJzVG9DcmFjayAqIDM2NSl9IGRheXNgO1xyXG4gICAgc3RyZW5ndGggPSAnV2Vhayc7XHJcbiAgfSBlbHNlIGlmICh5ZWFyc1RvQ3JhY2sgPCAxMDAwKSB7XHJcbiAgICB0aW1lVG9DcmFjayA9IGAke01hdGgucm91bmQoeWVhcnNUb0NyYWNrKX0geWVhcnNgO1xyXG4gICAgc3RyZW5ndGggPSAnTW9kZXJhdGUnO1xyXG4gIH0gZWxzZSBpZiAoeWVhcnNUb0NyYWNrIDwgMTAwMDAwMCkge1xyXG4gICAgdGltZVRvQ3JhY2sgPSBgJHtNYXRoLnJvdW5kKHllYXJzVG9DcmFjayAvIDEwMDApfUsgeWVhcnNgO1xyXG4gICAgc3RyZW5ndGggPSAnU3Ryb25nJztcclxuICB9IGVsc2Uge1xyXG4gICAgdGltZVRvQ3JhY2sgPSBgJHtNYXRoLnJvdW5kKHllYXJzVG9DcmFjayAvIDEwMDAwMDApfU0geWVhcnNgO1xyXG4gICAgc3RyZW5ndGggPSAnVmVyeSBTdHJvbmcnO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4ge1xyXG4gICAgZW50cm9weTogTWF0aC5yb3VuZChlbnRyb3B5KSxcclxuICAgIHRpbWVUb0NyYWNrLFxyXG4gICAgc3RyZW5ndGhcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogRXhwb3J0IHZhdWx0IGRhdGEgKGVuY3J5cHRlZClcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHBvcnRWYXVsdERhdGEoXHJcbiAgaXRlbXM6IFZhdWx0SXRlbVtdLFxyXG4gIG1hc3RlclBhc3N3b3JkOiBzdHJpbmdcclxuKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICBjb25zdCBleHBvcnREYXRhID0ge1xyXG4gICAgdmVyc2lvbjogMSxcclxuICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgaXRlbXM6IGF3YWl0IFByb21pc2UuYWxsKFxyXG4gICAgICBpdGVtcy5tYXAoaXRlbSA9PiBlbmNyeXB0VmF1bHRJdGVtKGl0ZW0sIG1hc3RlclBhc3N3b3JkKSlcclxuICAgIClcclxuICB9O1xyXG4gIFxyXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShleHBvcnREYXRhLCBudWxsLCAyKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEltcG9ydCB2YXVsdCBkYXRhIChkZWNyeXB0KVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGltcG9ydFZhdWx0RGF0YShcclxuICBleHBvcnRlZERhdGE6IHN0cmluZyxcclxuICBtYXN0ZXJQYXNzd29yZDogc3RyaW5nXHJcbik6IFByb21pc2U8VmF1bHRJdGVtW10+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXhwb3J0ZWREYXRhKTtcclxuICAgIFxyXG4gICAgaWYgKCFkYXRhLnZlcnNpb24gfHwgIWRhdGEuaXRlbXMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGV4cG9ydCBmaWxlIGZvcm1hdCcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBpdGVtcyA9IGF3YWl0IFByb21pc2UuYWxsKFxyXG4gICAgICBkYXRhLml0ZW1zLm1hcCgoZW5jcnlwdGVkSXRlbTogRW5jcnlwdGVkRGF0YSkgPT4gXHJcbiAgICAgICAgZGVjcnlwdFZhdWx0SXRlbShlbmNyeXB0ZWRJdGVtLCBtYXN0ZXJQYXNzd29yZClcclxuICAgICAgKVxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBpbXBvcnQgdmF1bHQgZGF0YS4gQ2hlY2sgeW91ciBtYXN0ZXIgcGFzc3dvcmQuJyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgV2ViIENyeXB0byBBUEkgaXMgYXZhaWxhYmxlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNDcnlwdG9BdmFpbGFibGUoKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIFxyXG4gICAgICAgICB0eXBlb2Ygd2luZG93LmNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgXHJcbiAgICAgICAgIHR5cGVvZiB3aW5kb3cuY3J5cHRvLnN1YnRsZSAhPT0gJ3VuZGVmaW5lZCc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBhIHNlY3VyZSByYW5kb20gSURcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVNlY3VyZUlkKGxlbmd0aDogbnVtYmVyID0gMTYpOiBzdHJpbmcge1xyXG4gIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcclxuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcclxuICByZXR1cm4gQXJyYXkuZnJvbShhcnJheSwgYnl0ZSA9PiBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcclxufSJdLCJuYW1lcyI6WyJkZXJpdmVLZXkiLCJtYXN0ZXJQYXNzd29yZCIsInNhbHQiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJrZXlNYXRlcmlhbCIsImNyeXB0byIsInN1YnRsZSIsImltcG9ydEtleSIsImVuY29kZSIsIm5hbWUiLCJpdGVyYXRpb25zIiwiaGFzaCIsImxlbmd0aCIsImVuY3J5cHRWYXVsdEl0ZW0iLCJkYXRhIiwiZ2V0UmFuZG9tVmFsdWVzIiwiVWludDhBcnJheSIsIml2Iiwia2V5IiwiZW5jcnlwdGVkIiwiZW5jcnlwdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJhcnJheUJ1ZmZlclRvQmFzZTY0IiwiZGVjcnlwdFZhdWx0SXRlbSIsImVuY3J5cHRlZERhdGEiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJiYXNlNjRUb0FycmF5QnVmZmVyIiwiZGVjcnlwdGVkIiwiZGVjcnlwdCIsInBhcnNlIiwiZGVjb2RlIiwiZ2VuZXJhdGVTZWN1cmVQYXNzd29yZCIsIm9wdGlvbnMiLCJsb3dlcmNhc2UiLCJ1cHBlcmNhc2UiLCJudW1iZXJzIiwic3ltYm9scyIsImFtYmlndW91cyIsImNoYXJzZXQiLCJpbmNsdWRlTnVtYmVycyIsImluY2x1ZGVTeW1ib2xzIiwiZXhjbHVkZUFtYmlndW91cyIsInNwbGl0IiwiZmlsdGVyIiwiYyIsImluY2x1ZGVzIiwiam9pbiIsInBhc3N3b3JkIiwicmFuZG9tVmFsdWVzIiwiVWludDMyQXJyYXkiLCJpIiwiaGFzaFBhc3N3b3JkIiwiZGlnZXN0IiwidmFsaWRhdGVQYXNzd29yZFN0cmVuZ3RoIiwiZXJyb3JzIiwicHVzaCIsInRlc3QiLCJpc1ZhbGlkIiwiYnVmZmVyIiwiYnl0ZXMiLCJBcnJheUJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiYmluYXJ5IiwiY2h1bmtTaXplIiwiY2h1bmsiLCJzdWJhcnJheSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5IiwiQXJyYXkiLCJmcm9tIiwiYnRvYSIsImJhc2U2NCIsImF0b2IiLCJjaGFyQ29kZUF0IiwiZ2VuZXJhdGVSYW5kb21LZXkiLCJnZW5lcmF0ZUtleSIsImNhbGN1bGF0ZVBhc3N3b3JkRW50cm9weSIsImNoYXJzZXRTaXplIiwiTWF0aCIsImxvZzIiLCJwb3ciLCJlc3RpbWF0ZVRpbWVUb0NyYWNrIiwiZW50cm9weSIsImd1ZXNzZXNQZXJTZWNvbmQiLCJzZWNvbmRzVG9DcmFjayIsInllYXJzVG9DcmFjayIsInRpbWVUb0NyYWNrIiwic3RyZW5ndGgiLCJyb3VuZCIsImV4cG9ydFZhdWx0RGF0YSIsIml0ZW1zIiwiZXhwb3J0RGF0YSIsInZlcnNpb24iLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiaXRlbSIsImltcG9ydFZhdWx0RGF0YSIsImV4cG9ydGVkRGF0YSIsIkVycm9yIiwiZW5jcnlwdGVkSXRlbSIsImVycm9yIiwiaXNDcnlwdG9BdmFpbGFibGUiLCJ3aW5kb3ciLCJnZW5lcmF0ZVNlY3VyZUlkIiwiYXJyYXkiLCJieXRlIiwidG9TdHJpbmciLCJwYWRTdGFydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/crypto.ts\n"));

/***/ })

});