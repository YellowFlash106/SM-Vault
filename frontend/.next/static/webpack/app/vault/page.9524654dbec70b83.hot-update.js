"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/vault/page",{

/***/ "(app-pages-browser)/./src/lib/crypto.ts":
/*!***************************!*\
  !*** ./src/lib/crypto.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculatePasswordEntropy: function() { return /* binding */ calculatePasswordEntropy; },\n/* harmony export */   decryptVaultItem: function() { return /* binding */ decryptVaultItem; },\n/* harmony export */   encryptVaultItem: function() { return /* binding */ encryptVaultItem; },\n/* harmony export */   estimateTimeToCrack: function() { return /* binding */ estimateTimeToCrack; },\n/* harmony export */   exportVaultData: function() { return /* binding */ exportVaultData; },\n/* harmony export */   generateRandomKey: function() { return /* binding */ generateRandomKey; },\n/* harmony export */   generateSecureId: function() { return /* binding */ generateSecureId; },\n/* harmony export */   generateSecurePassword: function() { return /* binding */ generateSecurePassword; },\n/* harmony export */   hashPassword: function() { return /* binding */ hashPassword; },\n/* harmony export */   importVaultData: function() { return /* binding */ importVaultData; },\n/* harmony export */   isCryptoAvailable: function() { return /* binding */ isCryptoAvailable; },\n/* harmony export */   validatePasswordStrength: function() { return /* binding */ validatePasswordStrength; }\n/* harmony export */ });\n// frontend/src/lib/crypto.ts\n/**\r\n * Client-side encryption using Web Crypto API\r\n * \r\n * Encryption Strategy:\r\n * - AES-GCM 256-bit encryption for vault data\r\n * - PBKDF2 with 100,000 iterations for key derivation\r\n * - Random salt and IV for each encryption operation\r\n * - Zero-knowledge architecture: server never sees plaintext\r\n */ /**\r\n * Derive encryption key from master password using PBKDF2\r\n */ async function deriveKey(masterPassword, salt) {\n    const encoder = new TextEncoder();\n    // Import the master password as key material\n    const keyMaterial = await crypto.subtle.importKey(\"raw\", encoder.encode(masterPassword), \"PBKDF2\", false, [\n        \"deriveBits\",\n        \"deriveKey\"\n    ]);\n    // Derive AES-GCM key using PBKDF2\n    return crypto.subtle.deriveKey({\n        name: \"PBKDF2\",\n        // cast to BufferSource to satisfy TypeScript lib differences\n        salt: salt,\n        iterations: 100000,\n        hash: \"SHA-256\"\n    }, keyMaterial, {\n        name: \"AES-GCM\",\n        length: 256\n    }, true, [\n        \"encrypt\",\n        \"decrypt\"\n    ]);\n}\n/**\r\n * Encrypt vault item data\r\n */ async function encryptVaultItem(data, masterPassword) {\n    const encoder = new TextEncoder();\n    // Generate random salt and IV\n    const salt = crypto.getRandomValues(new Uint8Array(16));\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    // Derive encryption key\n    const key = await deriveKey(masterPassword, salt);\n    // Encrypt the data\n    const encrypted = await crypto.subtle.encrypt({\n        name: \"AES-GCM\",\n        iv: iv\n    }, key, encoder.encode(JSON.stringify(data)));\n    // Convert to base64 for storage\n    return {\n        encrypted: arrayBufferToBase64(encrypted),\n        salt: arrayBufferToBase64(salt),\n        iv: arrayBufferToBase64(iv)\n    };\n}\n/**\r\n * Decrypt vault item data\r\n */ async function decryptVaultItem(encryptedData, masterPassword) {\n    const decoder = new TextDecoder();\n    // Convert from base64\n    const salt = base64ToArrayBuffer(encryptedData.salt);\n    const iv = base64ToArrayBuffer(encryptedData.iv);\n    const encrypted = base64ToArrayBuffer(encryptedData.encrypted);\n    // Derive decryption key\n    const key = await deriveKey(masterPassword, salt);\n    // Decrypt the data\n    const decrypted = await crypto.subtle.decrypt({\n        name: \"AES-GCM\",\n        iv: iv\n    }, key, encrypted);\n    // Parse and return the data\n    return JSON.parse(decoder.decode(decrypted));\n}\nfunction generateSecurePassword(options) {\n    const lowercase = \"abcdefghijklmnopqrstuvwxyz\";\n    const uppercase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    const numbers = \"0123456789\";\n    const symbols = \"!@#$%^&*()_+-=[]{}|;:,.<>?\";\n    const ambiguous = \"il1Lo0O\";\n    // Build character set\n    let charset = lowercase + uppercase;\n    if (options.includeNumbers) charset += numbers;\n    if (options.includeSymbols) charset += symbols;\n    // Remove ambiguous characters if requested\n    if (options.excludeAmbiguous) {\n        charset = charset.split(\"\").filter((c)=>!ambiguous.includes(c)).join(\"\");\n    }\n    // Generate password using crypto.getRandomValues for security\n    let password = \"\";\n    const randomValues = new Uint32Array(options.length);\n    crypto.getRandomValues(randomValues);\n    for(let i = 0; i < options.length; i++){\n        password += charset[randomValues[i] % charset.length];\n    }\n    return password;\n}\n/**\r\n * Hash password for authentication (client-side pre-hash)\r\n * Note: This is NOT for vault encryption, only for auth\r\n */ async function hashPassword(password) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(password);\n    const hash = await crypto.subtle.digest(\"SHA-256\", data);\n    return arrayBufferToBase64(hash);\n}\n/**\r\n * Validate master password strength\r\n */ function validatePasswordStrength(password) {\n    const errors = [];\n    if (password.length < 12) {\n        errors.push(\"Password must be at least 12 characters long\");\n    }\n    if (!/[a-z]/.test(password)) {\n        errors.push(\"Password must contain lowercase letters\");\n    }\n    if (!/[A-Z]/.test(password)) {\n        errors.push(\"Password must contain uppercase letters\");\n    }\n    if (!/[0-9]/.test(password)) {\n        errors.push(\"Password must contain numbers\");\n    }\n    if (!/[^a-zA-Z0-9]/.test(password)) {\n        errors.push(\"Password must contain special characters\");\n    }\n    return {\n        isValid: errors.length === 0,\n        errors\n    };\n}\n/**\r\n * Utility function: Convert ArrayBuffer to Base64 string\r\n */ function arrayBufferToBase64(buffer) {\n    // Normalize to Uint8Array view\n    const bytes = buffer instanceof ArrayBuffer ? new Uint8Array(buffer) : new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    let binary = \"\";\n    const chunkSize = 0x8000; // safe chunk to avoid call stack issues\n    for(let i = 0; i < bytes.length; i += chunkSize){\n        const chunk = bytes.subarray(i, i + chunkSize);\n        binary += String.fromCharCode.apply(null, Array.from(chunk));\n    }\n    return btoa(binary);\n}\n/**\r\n * Utility function: Convert Base64 string to Uint8Array\r\n */ function base64ToArrayBuffer(base64) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for(let i = 0; i < binary.length; i++){\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n/**\r\n * Generate a random encryption key (for testing/demo purposes)\r\n */ async function generateRandomKey() {\n    return crypto.subtle.generateKey({\n        name: \"AES-GCM\",\n        length: 256\n    }, true, [\n        \"encrypt\",\n        \"decrypt\"\n    ]);\n}\n/**\r\n * Calculate password entropy (bits of randomness)\r\n */ function calculatePasswordEntropy(password) {\n    let charsetSize = 0;\n    if (/[a-z]/.test(password)) charsetSize += 26;\n    if (/[A-Z]/.test(password)) charsetSize += 26;\n    if (/[0-9]/.test(password)) charsetSize += 10;\n    if (/[^a-zA-Z0-9]/.test(password)) charsetSize += 32; // Approximate\n    return Math.log2(Math.pow(charsetSize, password.length));\n}\n/**\r\n * Estimate time to crack password (in years)\r\n */ function estimateTimeToCrack(password) {\n    const entropy = calculatePasswordEntropy(password);\n    const guessesPerSecond = 1e9; // 1 billion guesses per second\n    const secondsToCrack = Math.pow(2, entropy) / guessesPerSecond;\n    const yearsToCrack = secondsToCrack / (365.25 * 24 * 60 * 60);\n    let timeToCrack;\n    let strength;\n    if (yearsToCrack < 0.001) {\n        timeToCrack = \"Instantly\";\n        strength = \"Very Weak\";\n    } else if (yearsToCrack < 1) {\n        timeToCrack = \"\".concat(Math.round(yearsToCrack * 365), \" days\");\n        strength = \"Weak\";\n    } else if (yearsToCrack < 1000) {\n        timeToCrack = \"\".concat(Math.round(yearsToCrack), \" years\");\n        strength = \"Moderate\";\n    } else if (yearsToCrack < 1000000) {\n        timeToCrack = \"\".concat(Math.round(yearsToCrack / 1000), \"K years\");\n        strength = \"Strong\";\n    } else {\n        timeToCrack = \"\".concat(Math.round(yearsToCrack / 1000000), \"M years\");\n        strength = \"Very Strong\";\n    }\n    return {\n        entropy: Math.round(entropy),\n        timeToCrack,\n        strength\n    };\n}\n/**\r\n * Export vault data (encrypted)\r\n */ async function exportVaultData(items, masterPassword) {\n    const exportData = {\n        version: 1,\n        timestamp: new Date().toISOString(),\n        items: await Promise.all(items.map((item)=>encryptVaultItem(item, masterPassword)))\n    };\n    return JSON.stringify(exportData, null, 2);\n}\n/**\r\n * Import vault data (decrypt)\r\n */ async function importVaultData(exportedData, masterPassword) {\n    try {\n        const data = JSON.parse(exportedData);\n        if (!data.version || !data.items) {\n            throw new Error(\"Invalid export file format\");\n        }\n        const items = await Promise.all(data.items.map((encryptedItem)=>decryptVaultItem(encryptedItem, masterPassword)));\n        return items;\n    } catch (error) {\n        throw new Error(\"Failed to import vault data. Check your master password.\");\n    }\n}\n/**\r\n * Check if Web Crypto API is available\r\n */ function isCryptoAvailable() {\n    return  true && typeof window.crypto !== \"undefined\" && typeof window.crypto.subtle !== \"undefined\";\n}\n/**\r\n * Generate a secure random ID\r\n */ function generateSecureId() {\n    let length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;\n    const array = new Uint8Array(length);\n    crypto.getRandomValues(array);\n    return Array.from(array, (byte)=>byte.toString(16).padStart(2, \"0\")).join(\"\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxPQUFRMUYsaUJBQWlCMEYsTUFBTXZHO0lBRTdDO0lBRUEsT0FBT3FCLEtBQUtDLFNBQVMsQ0FBQ3lFLFlBQVksTUFBTTtBQUMxQztBQUVBOztDQUVDLEdBQ00sZUFBZVMsZ0JBQ3BCQyxZQUFvQixFQUNwQnpHLGNBQXNCO0lBRXRCLElBQUk7UUFDRixNQUFNYyxPQUFPTyxLQUFLVSxLQUFLLENBQUMwRTtRQUV4QixJQUFJLENBQUMzRixLQUFLa0YsT0FBTyxJQUFJLENBQUNsRixLQUFLZ0YsS0FBSyxFQUFFO1lBQ2hDLE1BQU0sSUFBSVksTUFBTTtRQUNsQjtRQUVBLE1BQU1aLFFBQVEsTUFBTU0sUUFBUUMsR0FBRyxDQUM3QnZGLEtBQUtnRixLQUFLLENBQUNRLEdBQUcsQ0FBQyxDQUFDSyxnQkFDZG5GLGlCQUFpQm1GLGVBQWUzRztRQUlwQyxPQUFPOEY7SUFDVCxFQUFFLE9BQU9jLE9BQU87UUFDZCxNQUFNLElBQUlGLE1BQU07SUFDbEI7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU0c7SUFDZCxPQUFPLEtBQWtCLElBQ2xCLE9BQU9DLE9BQU96RyxNQUFNLEtBQUssZUFDekIsT0FBT3lHLE9BQU96RyxNQUFNLENBQUNDLE1BQU0sS0FBSztBQUN6QztBQUVBOztDQUVDLEdBQ00sU0FBU3lHO1FBQWlCbkcsU0FBQUEsaUVBQWlCO0lBQ2hELE1BQU1vRyxRQUFRLElBQUloRyxXQUFXSjtJQUM3QlAsT0FBT1UsZUFBZSxDQUFDaUc7SUFDdkIsT0FBT3hDLE1BQU1DLElBQUksQ0FBQ3VDLE9BQU9DLENBQUFBLE9BQVFBLEtBQUtDLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRyxNQUFNbkUsSUFBSSxDQUFDO0FBQzVFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvY3J5cHRvLnRzPzUwYmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnJvbnRlbmQvc3JjL2xpYi9jcnlwdG8udHNcclxuXHJcbi8qKlxyXG4gKiBDbGllbnQtc2lkZSBlbmNyeXB0aW9uIHVzaW5nIFdlYiBDcnlwdG8gQVBJXHJcbiAqIFxyXG4gKiBFbmNyeXB0aW9uIFN0cmF0ZWd5OlxyXG4gKiAtIEFFUy1HQ00gMjU2LWJpdCBlbmNyeXB0aW9uIGZvciB2YXVsdCBkYXRhXHJcbiAqIC0gUEJLREYyIHdpdGggMTAwLDAwMCBpdGVyYXRpb25zIGZvciBrZXkgZGVyaXZhdGlvblxyXG4gKiAtIFJhbmRvbSBzYWx0IGFuZCBJViBmb3IgZWFjaCBlbmNyeXB0aW9uIG9wZXJhdGlvblxyXG4gKiAtIFplcm8ta25vd2xlZGdlIGFyY2hpdGVjdHVyZTogc2VydmVyIG5ldmVyIHNlZXMgcGxhaW50ZXh0XHJcbiAqL1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFbmNyeXB0ZWREYXRhIHtcclxuICBlbmNyeXB0ZWQ6IHN0cmluZzsgIC8vIEJhc2U2NCBlbmNvZGVkIGVuY3J5cHRlZCBkYXRhXHJcbiAgc2FsdDogc3RyaW5nOyAgICAgICAvLyBCYXNlNjQgZW5jb2RlZCBzYWx0XHJcbiAgaXY6IHN0cmluZzsgICAgICAgICAvLyBCYXNlNjQgZW5jb2RlZCBpbml0aWFsaXphdGlvbiB2ZWN0b3JcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBWYXVsdEl0ZW0ge1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgdXNlcm5hbWU6IHN0cmluZztcclxuICBwYXNzd29yZDogc3RyaW5nO1xyXG4gIHVybDogc3RyaW5nO1xyXG4gIG5vdGVzOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXJpdmUgZW5jcnlwdGlvbiBrZXkgZnJvbSBtYXN0ZXIgcGFzc3dvcmQgdXNpbmcgUEJLREYyXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZXJpdmVLZXkoXHJcbiAgbWFzdGVyUGFzc3dvcmQ6IHN0cmluZyxcclxuICBzYWx0OiBCdWZmZXJTb3VyY2VcclxuKTogUHJvbWlzZTxDcnlwdG9LZXk+IHtcclxuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XHJcbiAgXHJcbiAgLy8gSW1wb3J0IHRoZSBtYXN0ZXIgcGFzc3dvcmQgYXMga2V5IG1hdGVyaWFsXHJcbiAgY29uc3Qga2V5TWF0ZXJpYWwgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcclxuICAgICdyYXcnLFxyXG4gICAgZW5jb2Rlci5lbmNvZGUobWFzdGVyUGFzc3dvcmQpLFxyXG4gICAgJ1BCS0RGMicsXHJcbiAgICBmYWxzZSxcclxuICAgIFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXVxyXG4gICk7XHJcbiAgXHJcbiAgLy8gRGVyaXZlIEFFUy1HQ00ga2V5IHVzaW5nIFBCS0RGMlxyXG4gIHJldHVybiBjcnlwdG8uc3VidGxlLmRlcml2ZUtleShcclxuICAgIHtcclxuICAgICAgbmFtZTogJ1BCS0RGMicsXHJcbiAgICAgIC8vIGNhc3QgdG8gQnVmZmVyU291cmNlIHRvIHNhdGlzZnkgVHlwZVNjcmlwdCBsaWIgZGlmZmVyZW5jZXNcclxuICAgICAgc2FsdDogc2FsdCBhcyB1bmtub3duIGFzIEJ1ZmZlclNvdXJjZSxcclxuICAgICAgaXRlcmF0aW9uczogMTAwMDAwLCAgLy8gSGlnaCBpdGVyYXRpb24gY291bnQgZm9yIHNlY3VyaXR5XHJcbiAgICAgIGhhc2g6ICdTSEEtMjU2J1xyXG4gICAgfSxcclxuICAgIGtleU1hdGVyaWFsLFxyXG4gICAgeyBuYW1lOiAnQUVTLUdDTScsIGxlbmd0aDogMjU2IH0sXHJcbiAgICB0cnVlLFxyXG4gICAgWydlbmNyeXB0JywgJ2RlY3J5cHQnXVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmNyeXB0IHZhdWx0IGl0ZW0gZGF0YVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRWYXVsdEl0ZW0oXHJcbiAgZGF0YTogVmF1bHRJdGVtLFxyXG4gIG1hc3RlclBhc3N3b3JkOiBzdHJpbmdcclxuKTogUHJvbWlzZTxFbmNyeXB0ZWREYXRhPiB7XHJcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xyXG4gIFxyXG4gIC8vIEdlbmVyYXRlIHJhbmRvbSBzYWx0IGFuZCBJVlxyXG4gIGNvbnN0IHNhbHQgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDE2KSk7XHJcbiAgY29uc3QgaXYgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDEyKSk7XHJcbiAgXHJcbiAgLy8gRGVyaXZlIGVuY3J5cHRpb24ga2V5XHJcbiAgY29uc3Qga2V5ID0gYXdhaXQgZGVyaXZlS2V5KG1hc3RlclBhc3N3b3JkLCBzYWx0KTtcclxuICBcclxuICAvLyBFbmNyeXB0IHRoZSBkYXRhXHJcbiAgY29uc3QgZW5jcnlwdGVkID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5lbmNyeXB0KFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAnQUVTLUdDTScsXHJcbiAgICAgIGl2OiBpdiBhcyB1bmtub3duIGFzIEJ1ZmZlclNvdXJjZVxyXG4gICAgfSxcclxuICAgIGtleSxcclxuICAgIGVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KGRhdGEpKVxyXG4gICk7XHJcbiAgXHJcbiAgLy8gQ29udmVydCB0byBiYXNlNjQgZm9yIHN0b3JhZ2VcclxuICByZXR1cm4ge1xyXG4gICAgZW5jcnlwdGVkOiBhcnJheUJ1ZmZlclRvQmFzZTY0KGVuY3J5cHRlZCksXHJcbiAgICBzYWx0OiBhcnJheUJ1ZmZlclRvQmFzZTY0KHNhbHQpLFxyXG4gICAgaXY6IGFycmF5QnVmZmVyVG9CYXNlNjQoaXYpXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERlY3J5cHQgdmF1bHQgaXRlbSBkYXRhXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVjcnlwdFZhdWx0SXRlbShcclxuICBlbmNyeXB0ZWREYXRhOiBFbmNyeXB0ZWREYXRhLFxyXG4gIG1hc3RlclBhc3N3b3JkOiBzdHJpbmdcclxuKTogUHJvbWlzZTxWYXVsdEl0ZW0+IHtcclxuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XHJcbiAgXHJcbiAgLy8gQ29udmVydCBmcm9tIGJhc2U2NFxyXG4gIGNvbnN0IHNhbHQgPSBiYXNlNjRUb0FycmF5QnVmZmVyKGVuY3J5cHRlZERhdGEuc2FsdCk7XHJcbiAgY29uc3QgaXYgPSBiYXNlNjRUb0FycmF5QnVmZmVyKGVuY3J5cHRlZERhdGEuaXYpO1xyXG4gIGNvbnN0IGVuY3J5cHRlZCA9IGJhc2U2NFRvQXJyYXlCdWZmZXIoZW5jcnlwdGVkRGF0YS5lbmNyeXB0ZWQpO1xyXG4gIFxyXG4gIC8vIERlcml2ZSBkZWNyeXB0aW9uIGtleVxyXG4gIGNvbnN0IGtleSA9IGF3YWl0IGRlcml2ZUtleShtYXN0ZXJQYXNzd29yZCwgIHNhbHQgYXMgdW5rbm93biBhcyBCdWZmZXJTb3VyY2UpO1xyXG4gIFxyXG4gIC8vIERlY3J5cHQgdGhlIGRhdGFcclxuICBjb25zdCBkZWNyeXB0ZWQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRlY3J5cHQoXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdBRVMtR0NNJyxcclxuICAgICAgaXY6IGl2IGFzIHVua25vd24gYXMgQnVmZmVyU291cmNlXHJcbiAgICB9LFxyXG4gICAga2V5LFxyXG4gICAgZW5jcnlwdGVkIGFzIHVua25vd24gYXMgQnVmZmVyU291cmNlXHJcbiAgKTtcclxuICBcclxuICAvLyBQYXJzZSBhbmQgcmV0dXJuIHRoZSBkYXRhXHJcbiAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2Rlci5kZWNvZGUoZGVjcnlwdGVkKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcmFuZG9tIHBhc3N3b3JkXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFBhc3N3b3JkT3B0aW9ucyB7XHJcbiAgbGVuZ3RoOiBudW1iZXI7XHJcbiAgaW5jbHVkZU51bWJlcnM6IGJvb2xlYW47XHJcbiAgaW5jbHVkZVN5bWJvbHM6IGJvb2xlYW47XHJcbiAgZXhjbHVkZUFtYmlndW91czogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlU2VjdXJlUGFzc3dvcmQob3B0aW9uczogUGFzc3dvcmRPcHRpb25zKTogc3RyaW5nIHtcclxuICBjb25zdCBsb3dlcmNhc2UgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xyXG4gIGNvbnN0IHVwcGVyY2FzZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWic7XHJcbiAgY29uc3QgbnVtYmVycyA9ICcwMTIzNDU2Nzg5JztcclxuICBjb25zdCBzeW1ib2xzID0gJyFAIyQlXiYqKClfKy09W117fXw7OiwuPD4/JztcclxuICBjb25zdCBhbWJpZ3VvdXMgPSAnaWwxTG8wTyc7XHJcbiAgXHJcbiAgLy8gQnVpbGQgY2hhcmFjdGVyIHNldFxyXG4gIGxldCBjaGFyc2V0ID0gbG93ZXJjYXNlICsgdXBwZXJjYXNlO1xyXG4gIGlmIChvcHRpb25zLmluY2x1ZGVOdW1iZXJzKSBjaGFyc2V0ICs9IG51bWJlcnM7XHJcbiAgaWYgKG9wdGlvbnMuaW5jbHVkZVN5bWJvbHMpIGNoYXJzZXQgKz0gc3ltYm9scztcclxuICBcclxuICAvLyBSZW1vdmUgYW1iaWd1b3VzIGNoYXJhY3RlcnMgaWYgcmVxdWVzdGVkXHJcbiAgaWYgKG9wdGlvbnMuZXhjbHVkZUFtYmlndW91cykge1xyXG4gICAgY2hhcnNldCA9IGNoYXJzZXQuc3BsaXQoJycpLmZpbHRlcihjID0+ICFhbWJpZ3VvdXMuaW5jbHVkZXMoYykpLmpvaW4oJycpO1xyXG4gIH1cclxuICBcclxuICAvLyBHZW5lcmF0ZSBwYXNzd29yZCB1c2luZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIGZvciBzZWN1cml0eVxyXG4gIGxldCBwYXNzd29yZCA9ICcnO1xyXG4gIGNvbnN0IHJhbmRvbVZhbHVlcyA9IG5ldyBVaW50MzJBcnJheShvcHRpb25zLmxlbmd0aCk7XHJcbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhyYW5kb21WYWx1ZXMpO1xyXG4gIFxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgcGFzc3dvcmQgKz0gY2hhcnNldFtyYW5kb21WYWx1ZXNbaV0gJSBjaGFyc2V0Lmxlbmd0aF07XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBwYXNzd29yZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhhc2ggcGFzc3dvcmQgZm9yIGF1dGhlbnRpY2F0aW9uIChjbGllbnQtc2lkZSBwcmUtaGFzaClcclxuICogTm90ZTogVGhpcyBpcyBOT1QgZm9yIHZhdWx0IGVuY3J5cHRpb24sIG9ubHkgZm9yIGF1dGhcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYXNoUGFzc3dvcmQocGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xyXG4gIGNvbnN0IGRhdGEgPSBlbmNvZGVyLmVuY29kZShwYXNzd29yZCk7XHJcbiAgY29uc3QgaGFzaCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgZGF0YSk7XHJcbiAgcmV0dXJuIGFycmF5QnVmZmVyVG9CYXNlNjQoaGFzaCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSBtYXN0ZXIgcGFzc3dvcmQgc3RyZW5ndGhcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVBhc3N3b3JkU3RyZW5ndGgocGFzc3dvcmQ6IHN0cmluZyk6IHtcclxuICBpc1ZhbGlkOiBib29sZWFuO1xyXG4gIGVycm9yczogc3RyaW5nW107XHJcbn0ge1xyXG4gIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcclxuICBcclxuICBpZiAocGFzc3dvcmQubGVuZ3RoIDwgMTIpIHtcclxuICAgIGVycm9ycy5wdXNoKCdQYXNzd29yZCBtdXN0IGJlIGF0IGxlYXN0IDEyIGNoYXJhY3RlcnMgbG9uZycpO1xyXG4gIH1cclxuICBpZiAoIS9bYS16XS8udGVzdChwYXNzd29yZCkpIHtcclxuICAgIGVycm9ycy5wdXNoKCdQYXNzd29yZCBtdXN0IGNvbnRhaW4gbG93ZXJjYXNlIGxldHRlcnMnKTtcclxuICB9XHJcbiAgaWYgKCEvW0EtWl0vLnRlc3QocGFzc3dvcmQpKSB7XHJcbiAgICBlcnJvcnMucHVzaCgnUGFzc3dvcmQgbXVzdCBjb250YWluIHVwcGVyY2FzZSBsZXR0ZXJzJyk7XHJcbiAgfVxyXG4gIGlmICghL1swLTldLy50ZXN0KHBhc3N3b3JkKSkge1xyXG4gICAgZXJyb3JzLnB1c2goJ1Bhc3N3b3JkIG11c3QgY29udGFpbiBudW1iZXJzJyk7XHJcbiAgfVxyXG4gIGlmICghL1teYS16QS1aMC05XS8udGVzdChwYXNzd29yZCkpIHtcclxuICAgIGVycm9ycy5wdXNoKCdQYXNzd29yZCBtdXN0IGNvbnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzJyk7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICBpc1ZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxyXG4gICAgZXJyb3JzXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb246IENvbnZlcnQgQXJyYXlCdWZmZXIgdG8gQmFzZTY0IHN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NChidWZmZXI6IEFycmF5QnVmZmVyIHwgQXJyYXlCdWZmZXJWaWV3KTogc3RyaW5nIHtcclxuICAvLyBOb3JtYWxpemUgdG8gVWludDhBcnJheSB2aWV3XHJcbiAgY29uc3QgYnl0ZXMgPSBidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclxyXG4gICAgPyBuZXcgVWludDhBcnJheShidWZmZXIpXHJcbiAgICA6IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XHJcblxyXG4gIGxldCBiaW5hcnkgPSAnJztcclxuICBjb25zdCBjaHVua1NpemUgPSAweDgwMDA7IC8vIHNhZmUgY2h1bmsgdG8gYXZvaWQgY2FsbCBzdGFjayBpc3N1ZXNcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcclxuICAgIGNvbnN0IGNodW5rID0gYnl0ZXMuc3ViYXJyYXkoaSwgaSArIGNodW5rU2l6ZSk7XHJcbiAgICBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBBcnJheS5mcm9tKGNodW5rKSk7XHJcbiAgfVxyXG4gIHJldHVybiBidG9hKGJpbmFyeSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9uOiBDb252ZXJ0IEJhc2U2NCBzdHJpbmcgdG8gVWludDhBcnJheVxyXG4gKi9cclxuZnVuY3Rpb24gYmFzZTY0VG9BcnJheUJ1ZmZlcihiYXNlNjQ6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xyXG4gIGNvbnN0IGJpbmFyeSA9IGF0b2IoYmFzZTY0KTtcclxuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeS5sZW5ndGgpO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBieXRlc1tpXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGkpO1xyXG4gIH1cclxuICByZXR1cm4gYnl0ZXM7XHJcbn1cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIGVuY3J5cHRpb24ga2V5IChmb3IgdGVzdGluZy9kZW1vIHB1cnBvc2VzKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tS2V5KCk6IFByb21pc2U8Q3J5cHRvS2V5PiB7XHJcbiAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZ2VuZXJhdGVLZXkoXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdBRVMtR0NNJyxcclxuICAgICAgbGVuZ3RoOiAyNTZcclxuICAgIH0sXHJcbiAgICB0cnVlLFxyXG4gICAgWydlbmNyeXB0JywgJ2RlY3J5cHQnXVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgcGFzc3dvcmQgZW50cm9weSAoYml0cyBvZiByYW5kb21uZXNzKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVBhc3N3b3JkRW50cm9weShwYXNzd29yZDogc3RyaW5nKTogbnVtYmVyIHtcclxuICBsZXQgY2hhcnNldFNpemUgPSAwO1xyXG4gIFxyXG4gIGlmICgvW2Etel0vLnRlc3QocGFzc3dvcmQpKSBjaGFyc2V0U2l6ZSArPSAyNjtcclxuICBpZiAoL1tBLVpdLy50ZXN0KHBhc3N3b3JkKSkgY2hhcnNldFNpemUgKz0gMjY7XHJcbiAgaWYgKC9bMC05XS8udGVzdChwYXNzd29yZCkpIGNoYXJzZXRTaXplICs9IDEwO1xyXG4gIGlmICgvW15hLXpBLVowLTldLy50ZXN0KHBhc3N3b3JkKSkgY2hhcnNldFNpemUgKz0gMzI7IC8vIEFwcHJveGltYXRlXHJcbiAgXHJcbiAgcmV0dXJuIE1hdGgubG9nMihNYXRoLnBvdyhjaGFyc2V0U2l6ZSwgcGFzc3dvcmQubGVuZ3RoKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFc3RpbWF0ZSB0aW1lIHRvIGNyYWNrIHBhc3N3b3JkIChpbiB5ZWFycylcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlc3RpbWF0ZVRpbWVUb0NyYWNrKHBhc3N3b3JkOiBzdHJpbmcpOiB7XHJcbiAgZW50cm9weTogbnVtYmVyO1xyXG4gIHRpbWVUb0NyYWNrOiBzdHJpbmc7XHJcbiAgc3RyZW5ndGg6ICdWZXJ5IFdlYWsnIHwgJ1dlYWsnIHwgJ01vZGVyYXRlJyB8ICdTdHJvbmcnIHwgJ1ZlcnkgU3Ryb25nJztcclxufSB7XHJcbiAgY29uc3QgZW50cm9weSA9IGNhbGN1bGF0ZVBhc3N3b3JkRW50cm9weShwYXNzd29yZCk7XHJcbiAgY29uc3QgZ3Vlc3Nlc1BlclNlY29uZCA9IDFlOTsgLy8gMSBiaWxsaW9uIGd1ZXNzZXMgcGVyIHNlY29uZFxyXG4gIGNvbnN0IHNlY29uZHNUb0NyYWNrID0gTWF0aC5wb3coMiwgZW50cm9weSkgLyBndWVzc2VzUGVyU2Vjb25kO1xyXG4gIGNvbnN0IHllYXJzVG9DcmFjayA9IHNlY29uZHNUb0NyYWNrIC8gKDM2NS4yNSAqIDI0ICogNjAgKiA2MCk7XHJcbiAgXHJcbiAgbGV0IHRpbWVUb0NyYWNrOiBzdHJpbmc7XHJcbiAgbGV0IHN0cmVuZ3RoOiAnVmVyeSBXZWFrJyB8ICdXZWFrJyB8ICdNb2RlcmF0ZScgfCAnU3Ryb25nJyB8ICdWZXJ5IFN0cm9uZyc7XHJcbiAgXHJcbiAgaWYgKHllYXJzVG9DcmFjayA8IDAuMDAxKSB7XHJcbiAgICB0aW1lVG9DcmFjayA9ICdJbnN0YW50bHknO1xyXG4gICAgc3RyZW5ndGggPSAnVmVyeSBXZWFrJztcclxuICB9IGVsc2UgaWYgKHllYXJzVG9DcmFjayA8IDEpIHtcclxuICAgIHRpbWVUb0NyYWNrID0gYCR7TWF0aC5yb3VuZCh5ZWFyc1RvQ3JhY2sgKiAzNjUpfSBkYXlzYDtcclxuICAgIHN0cmVuZ3RoID0gJ1dlYWsnO1xyXG4gIH0gZWxzZSBpZiAoeWVhcnNUb0NyYWNrIDwgMTAwMCkge1xyXG4gICAgdGltZVRvQ3JhY2sgPSBgJHtNYXRoLnJvdW5kKHllYXJzVG9DcmFjayl9IHllYXJzYDtcclxuICAgIHN0cmVuZ3RoID0gJ01vZGVyYXRlJztcclxuICB9IGVsc2UgaWYgKHllYXJzVG9DcmFjayA8IDEwMDAwMDApIHtcclxuICAgIHRpbWVUb0NyYWNrID0gYCR7TWF0aC5yb3VuZCh5ZWFyc1RvQ3JhY2sgLyAxMDAwKX1LIHllYXJzYDtcclxuICAgIHN0cmVuZ3RoID0gJ1N0cm9uZyc7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRpbWVUb0NyYWNrID0gYCR7TWF0aC5yb3VuZCh5ZWFyc1RvQ3JhY2sgLyAxMDAwMDAwKX1NIHllYXJzYDtcclxuICAgIHN0cmVuZ3RoID0gJ1ZlcnkgU3Ryb25nJztcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIGVudHJvcHk6IE1hdGgucm91bmQoZW50cm9weSksXHJcbiAgICB0aW1lVG9DcmFjayxcclxuICAgIHN0cmVuZ3RoXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEV4cG9ydCB2YXVsdCBkYXRhIChlbmNyeXB0ZWQpXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwb3J0VmF1bHREYXRhKFxyXG4gIGl0ZW1zOiBWYXVsdEl0ZW1bXSxcclxuICBtYXN0ZXJQYXNzd29yZDogc3RyaW5nXHJcbik6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgY29uc3QgZXhwb3J0RGF0YSA9IHtcclxuICAgIHZlcnNpb246IDEsXHJcbiAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIGl0ZW1zOiBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgICAgaXRlbXMubWFwKGl0ZW0gPT4gZW5jcnlwdFZhdWx0SXRlbShpdGVtLCBtYXN0ZXJQYXNzd29yZCkpXHJcbiAgICApXHJcbiAgfTtcclxuICBcclxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXhwb3J0RGF0YSwgbnVsbCwgMik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbXBvcnQgdmF1bHQgZGF0YSAoZGVjcnlwdClcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXBvcnRWYXVsdERhdGEoXHJcbiAgZXhwb3J0ZWREYXRhOiBzdHJpbmcsXHJcbiAgbWFzdGVyUGFzc3dvcmQ6IHN0cmluZ1xyXG4pOiBQcm9taXNlPFZhdWx0SXRlbVtdPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV4cG9ydGVkRGF0YSk7XHJcbiAgICBcclxuICAgIGlmICghZGF0YS52ZXJzaW9uIHx8ICFkYXRhLml0ZW1zKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBleHBvcnQgZmlsZSBmb3JtYXQnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgICAgZGF0YS5pdGVtcy5tYXAoKGVuY3J5cHRlZEl0ZW06IEVuY3J5cHRlZERhdGEpID0+IFxyXG4gICAgICAgIGRlY3J5cHRWYXVsdEl0ZW0oZW5jcnlwdGVkSXRlbSwgbWFzdGVyUGFzc3dvcmQpXHJcbiAgICAgIClcclxuICAgICk7XHJcbiAgICBcclxuICAgIHJldHVybiBpdGVtcztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gaW1wb3J0IHZhdWx0IGRhdGEuIENoZWNrIHlvdXIgbWFzdGVyIHBhc3N3b3JkLicpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIFdlYiBDcnlwdG8gQVBJIGlzIGF2YWlsYWJsZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQ3J5cHRvQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBcclxuICAgICAgICAgdHlwZW9mIHdpbmRvdy5jcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIFxyXG4gICAgICAgICB0eXBlb2Ygd2luZG93LmNyeXB0by5zdWJ0bGUgIT09ICd1bmRlZmluZWQnO1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgYSBzZWN1cmUgcmFuZG9tIElEXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTZWN1cmVJZChsZW5ndGg6IG51bWJlciA9IDE2KTogc3RyaW5nIHtcclxuICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XHJcbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSk7XHJcbiAgcmV0dXJuIEFycmF5LmZyb20oYXJyYXksIGJ5dGUgPT4gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyk7XHJcbn0iXSwibmFtZXMiOlsiZGVyaXZlS2V5IiwibWFzdGVyUGFzc3dvcmQiLCJzYWx0IiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwia2V5TWF0ZXJpYWwiLCJjcnlwdG8iLCJzdWJ0bGUiLCJpbXBvcnRLZXkiLCJlbmNvZGUiLCJuYW1lIiwiaXRlcmF0aW9ucyIsImhhc2giLCJsZW5ndGgiLCJlbmNyeXB0VmF1bHRJdGVtIiwiZGF0YSIsImdldFJhbmRvbVZhbHVlcyIsIlVpbnQ4QXJyYXkiLCJpdiIsImtleSIsImVuY3J5cHRlZCIsImVuY3J5cHQiLCJKU09OIiwic3RyaW5naWZ5IiwiYXJyYXlCdWZmZXJUb0Jhc2U2NCIsImRlY3J5cHRWYXVsdEl0ZW0iLCJlbmNyeXB0ZWREYXRhIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiYmFzZTY0VG9BcnJheUJ1ZmZlciIsImRlY3J5cHRlZCIsImRlY3J5cHQiLCJwYXJzZSIsImRlY29kZSIsImdlbmVyYXRlU2VjdXJlUGFzc3dvcmQiLCJvcHRpb25zIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIiwibnVtYmVycyIsInN5bWJvbHMiLCJhbWJpZ3VvdXMiLCJjaGFyc2V0IiwiaW5jbHVkZU51bWJlcnMiLCJpbmNsdWRlU3ltYm9scyIsImV4Y2x1ZGVBbWJpZ3VvdXMiLCJzcGxpdCIsImZpbHRlciIsImMiLCJpbmNsdWRlcyIsImpvaW4iLCJwYXNzd29yZCIsInJhbmRvbVZhbHVlcyIsIlVpbnQzMkFycmF5IiwiaSIsImhhc2hQYXNzd29yZCIsImRpZ2VzdCIsInZhbGlkYXRlUGFzc3dvcmRTdHJlbmd0aCIsImVycm9ycyIsInB1c2giLCJ0ZXN0IiwiaXNWYWxpZCIsImJ1ZmZlciIsImJ5dGVzIiwiQXJyYXlCdWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsImJpbmFyeSIsImNodW5rU2l6ZSIsImNodW5rIiwic3ViYXJyYXkiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsIkFycmF5IiwiZnJvbSIsImJ0b2EiLCJiYXNlNjQiLCJhdG9iIiwiY2hhckNvZGVBdCIsImdlbmVyYXRlUmFuZG9tS2V5IiwiZ2VuZXJhdGVLZXkiLCJjYWxjdWxhdGVQYXNzd29yZEVudHJvcHkiLCJjaGFyc2V0U2l6ZSIsIk1hdGgiLCJsb2cyIiwicG93IiwiZXN0aW1hdGVUaW1lVG9DcmFjayIsImVudHJvcHkiLCJndWVzc2VzUGVyU2Vjb25kIiwic2Vjb25kc1RvQ3JhY2siLCJ5ZWFyc1RvQ3JhY2siLCJ0aW1lVG9DcmFjayIsInN0cmVuZ3RoIiwicm91bmQiLCJleHBvcnRWYXVsdERhdGEiLCJpdGVtcyIsImV4cG9ydERhdGEiLCJ2ZXJzaW9uIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsIml0ZW0iLCJpbXBvcnRWYXVsdERhdGEiLCJleHBvcnRlZERhdGEiLCJFcnJvciIsImVuY3J5cHRlZEl0ZW0iLCJlcnJvciIsImlzQ3J5cHRvQXZhaWxhYmxlIiwid2luZG93IiwiZ2VuZXJhdGVTZWN1cmVJZCIsImFycmF5IiwiYnl0ZSIsInRvU3RyaW5nIiwicGFkU3RhcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/crypto.ts\n"));

/***/ })

});