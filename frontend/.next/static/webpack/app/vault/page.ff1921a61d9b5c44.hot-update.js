"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/vault/page",{

/***/ "(app-pages-browser)/./src/lib/crypto.ts":
/*!***************************!*\
  !*** ./src/lib/crypto.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculatePasswordEntropy: function() { return /* binding */ calculatePasswordEntropy; },\n/* harmony export */   decryptVaultItem: function() { return /* binding */ decryptVaultItem; },\n/* harmony export */   encryptVaultItem: function() { return /* binding */ encryptVaultItem; },\n/* harmony export */   estimateTimeToCrack: function() { return /* binding */ estimateTimeToCrack; },\n/* harmony export */   exportVaultData: function() { return /* binding */ exportVaultData; },\n/* harmony export */   generateRandomKey: function() { return /* binding */ generateRandomKey; },\n/* harmony export */   generateSecureId: function() { return /* binding */ generateSecureId; },\n/* harmony export */   generateSecurePassword: function() { return /* binding */ generateSecurePassword; },\n/* harmony export */   hashPassword: function() { return /* binding */ hashPassword; },\n/* harmony export */   importVaultData: function() { return /* binding */ importVaultData; },\n/* harmony export */   isCryptoAvailable: function() { return /* binding */ isCryptoAvailable; },\n/* harmony export */   validatePasswordStrength: function() { return /* binding */ validatePasswordStrength; }\n/* harmony export */ });\n// frontend/src/lib/crypto.ts\n/**\r\n * Client-side encryption using Web Crypto API\r\n * \r\n * Encryption Strategy:\r\n * - AES-GCM 256-bit encryption for vault data\r\n * - PBKDF2 with 100,000 iterations for key derivation\r\n * - Random salt and IV for each encryption operation\r\n * - Zero-knowledge architecture: server never sees plaintext\r\n */ /**\r\n * Derive encryption key from master password using PBKDF2\r\n */ async function deriveKey(masterPassword, salt) {\n    const encoder = new TextEncoder();\n    // Import the master password as key material\n    const keyMaterial = await crypto.subtle.importKey(\"raw\", encoder.encode(masterPassword), \"PBKDF2\", false, [\n        \"deriveBits\",\n        \"deriveKey\"\n    ]);\n    // Derive AES-GCM key using PBKDF2\n    return crypto.subtle.deriveKey({\n        name: \"PBKDF2\",\n        salt: salt,\n        iterations: 100000,\n        hash: \"SHA-256\"\n    }, keyMaterial, {\n        name: \"AES-GCM\",\n        length: 256\n    }, true, [\n        \"encrypt\",\n        \"decrypt\"\n    ]);\n}\n/**\r\n * Encrypt vault item data\r\n */ async function encryptVaultItem(data, masterPassword) {\n    const encoder = new TextEncoder();\n    // Generate random salt and IV\n    const salt = crypto.getRandomValues(new Uint8Array(16));\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    // Derive encryption key\n    const key = await deriveKey(masterPassword, salt);\n    // Encrypt the data\n    const encrypted = await crypto.subtle.encrypt({\n        name: \"AES-GCM\",\n        iv: iv\n    }, key, encoder.encode(JSON.stringify(data)));\n    // Convert to base64 for storage\n    return {\n        encrypted: arrayBufferToBase64(encrypted),\n        salt: arrayBufferToBase64(salt),\n        iv: arrayBufferToBase64(iv)\n    };\n}\n/**\r\n * Decrypt vault item data\r\n */ async function decryptVaultItem(encryptedData, masterPassword) {\n    const decoder = new TextDecoder();\n    // Convert from base64\n    const salt = base64ToArrayBuffer(encryptedData.salt);\n    const iv = base64ToArrayBuffer(encryptedData.iv);\n    const encrypted = base64ToArrayBuffer(encryptedData.encrypted);\n    // Derive decryption key\n    const key = await deriveKey(masterPassword, salt);\n    // Decrypt the data\n    const decrypted = await crypto.subtle.decrypt({\n        name: \"AES-GCM\",\n        iv: iv\n    }, key, encrypted);\n    // Parse and return the data\n    return JSON.parse(decoder.decode(decrypted));\n}\nfunction generateSecurePassword(options) {\n    const lowercase = \"abcdefghijklmnopqrstuvwxyz\";\n    const uppercase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    const numbers = \"0123456789\";\n    const symbols = \"!@#$%^&*()_+-=[]{}|;:,.<>?\";\n    const ambiguous = \"il1Lo0O\";\n    // Build character set\n    let charset = lowercase + uppercase;\n    if (options.includeNumbers) charset += numbers;\n    if (options.includeSymbols) charset += symbols;\n    // Remove ambiguous characters if requested\n    if (options.excludeAmbiguous) {\n        charset = charset.split(\"\").filter((c)=>!ambiguous.includes(c)).join(\"\");\n    }\n    // Generate password using crypto.getRandomValues for security\n    let password = \"\";\n    const randomValues = new Uint32Array(options.length);\n    crypto.getRandomValues(randomValues);\n    for(let i = 0; i < options.length; i++){\n        password += charset[randomValues[i] % charset.length];\n    }\n    return password;\n}\n/**\r\n * Hash password for authentication (client-side pre-hash)\r\n * Note: This is NOT for vault encryption, only for auth\r\n */ async function hashPassword(password) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(password);\n    const hash = await crypto.subtle.digest(\"SHA-256\", data);\n    return arrayBufferToBase64(hash);\n}\n/**\r\n * Validate master password strength\r\n */ function validatePasswordStrength(password) {\n    const errors = [];\n    if (password.length < 12) {\n        errors.push(\"Password must be at least 12 characters long\");\n    }\n    if (!/[a-z]/.test(password)) {\n        errors.push(\"Password must contain lowercase letters\");\n    }\n    if (!/[A-Z]/.test(password)) {\n        errors.push(\"Password must contain uppercase letters\");\n    }\n    if (!/[0-9]/.test(password)) {\n        errors.push(\"Password must contain numbers\");\n    }\n    if (!/[^a-zA-Z0-9]/.test(password)) {\n        errors.push(\"Password must contain special characters\");\n    }\n    return {\n        isValid: errors.length === 0,\n        errors\n    };\n}\n/**\r\n * Utility function: Convert ArrayBuffer to Base64 string\r\n */ function arrayBufferToBase64(buffer) {\n    // Normalize to Uint8Array view\n    const bytes = buffer instanceof ArrayBuffer ? new Uint8Array(buffer) : new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    let binary = \"\";\n    const chunkSize = 0x8000; // safe chunk to avoid call stack issues\n    for(let i = 0; i < bytes.length; i += chunkSize){\n        const chunk = bytes.subarray(i, i + chunkSize);\n        binary += String.fromCharCode.apply(null, Array.from(chunk));\n    }\n    return btoa(binary);\n}\n/**\r\n * Utility function: Convert Base64 string to Uint8Array\r\n */ function base64ToArrayBuffer(base64) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for(let i = 0; i < binary.length; i++){\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n/**\r\n * Generate a random encryption key (for testing/demo purposes)\r\n */ async function generateRandomKey() {\n    return crypto.subtle.generateKey({\n        name: \"AES-GCM\",\n        length: 256\n    }, true, [\n        \"encrypt\",\n        \"decrypt\"\n    ]);\n}\n/**\r\n * Calculate password entropy (bits of randomness)\r\n */ function calculatePasswordEntropy(password) {\n    let charsetSize = 0;\n    if (/[a-z]/.test(password)) charsetSize += 26;\n    if (/[A-Z]/.test(password)) charsetSize += 26;\n    if (/[0-9]/.test(password)) charsetSize += 10;\n    if (/[^a-zA-Z0-9]/.test(password)) charsetSize += 32; // Approximate\n    return Math.log2(Math.pow(charsetSize, password.length));\n}\n/**\r\n * Estimate time to crack password (in years)\r\n */ function estimateTimeToCrack(password) {\n    const entropy = calculatePasswordEntropy(password);\n    const guessesPerSecond = 1e9; // 1 billion guesses per second\n    const secondsToCrack = Math.pow(2, entropy) / guessesPerSecond;\n    const yearsToCrack = secondsToCrack / (365.25 * 24 * 60 * 60);\n    let timeToCrack;\n    let strength;\n    if (yearsToCrack < 0.001) {\n        timeToCrack = \"Instantly\";\n        strength = \"Very Weak\";\n    } else if (yearsToCrack < 1) {\n        timeToCrack = \"\".concat(Math.round(yearsToCrack * 365), \" days\");\n        strength = \"Weak\";\n    } else if (yearsToCrack < 1000) {\n        timeToCrack = \"\".concat(Math.round(yearsToCrack), \" years\");\n        strength = \"Moderate\";\n    } else if (yearsToCrack < 1000000) {\n        timeToCrack = \"\".concat(Math.round(yearsToCrack / 1000), \"K years\");\n        strength = \"Strong\";\n    } else {\n        timeToCrack = \"\".concat(Math.round(yearsToCrack / 1000000), \"M years\");\n        strength = \"Very Strong\";\n    }\n    return {\n        entropy: Math.round(entropy),\n        timeToCrack,\n        strength\n    };\n}\n/**\r\n * Export vault data (encrypted)\r\n */ async function exportVaultData(items, masterPassword) {\n    const exportData = {\n        version: 1,\n        timestamp: new Date().toISOString(),\n        items: await Promise.all(items.map((item)=>encryptVaultItem(item, masterPassword)))\n    };\n    return JSON.stringify(exportData, null, 2);\n}\n/**\r\n * Import vault data (decrypt)\r\n */ async function importVaultData(exportedData, masterPassword) {\n    try {\n        const data = JSON.parse(exportedData);\n        if (!data.version || !data.items) {\n            throw new Error(\"Invalid export file format\");\n        }\n        const items = await Promise.all(data.items.map((encryptedItem)=>decryptVaultItem(encryptedItem, masterPassword)));\n        return items;\n    } catch (error) {\n        throw new Error(\"Failed to import vault data. Check your master password.\");\n    }\n}\n/**\r\n * Check if Web Crypto API is available\r\n */ function isCryptoAvailable() {\n    return  true && typeof window.crypto !== \"undefined\" && typeof window.crypto.subtle !== \"undefined\";\n}\n/**\r\n * Generate a secure random ID\r\n */ function generateSecureId() {\n    let length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;\n    const array = new Uint8Array(length);\n    crypto.getRandomValues(array);\n    return Array.from(array, (byte)=>byte.toString(16).padStart(2, \"0\")).join(\"\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY3J5cHRvLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZCQUE2QjtBQUU3Qjs7Ozs7Ozs7Q0FRQyxHQWdCRDs7Q0FFQyxHQUNELGVBQWVBLFVBQ2JDLGNBQXNCLEVBQ3RCQyxJQUFnQjtJQUVoQixNQUFNQyxVQUFVLElBQUlDO0lBRXBCLDZDQUE2QztJQUM3QyxNQUFNQyxjQUFjLE1BQU1DLE9BQU9DLE1BQU0sQ0FBQ0MsU0FBUyxDQUMvQyxPQUNBTCxRQUFRTSxNQUFNLENBQUNSLGlCQUNmLFVBQ0EsT0FDQTtRQUFDO1FBQWM7S0FBWTtJQUc3QixrQ0FBa0M7SUFDbEMsT0FBT0ssT0FBT0MsTUFBTSxDQUFDUCxTQUFTLENBQzVCO1FBQ0VVLE1BQU07UUFDTlIsTUFBTUE7UUFDTlMsWUFBWTtRQUNaQyxNQUFNO0lBQ1IsR0FDQVAsYUFDQTtRQUFFSyxNQUFNO1FBQVdHLFFBQVE7SUFBSSxHQUMvQixNQUNBO1FBQUM7UUFBVztLQUFVO0FBRTFCO0FBRUE7O0NBRUMsR0FDTSxlQUFlQyxpQkFDcEJDLElBQWUsRUFDZmQsY0FBc0I7SUFFdEIsTUFBTUUsVUFBVSxJQUFJQztJQUVwQiw4QkFBOEI7SUFDOUIsTUFBTUYsT0FBT0ksT0FBT1UsZUFBZSxDQUFDLElBQUlDLFdBQVc7SUFDbkQsTUFBTUMsS0FBS1osT0FBT1UsZUFBZSxDQUFDLElBQUlDLFdBQVc7SUFFakQsd0JBQXdCO0lBQ3hCLE1BQU1FLE1BQU0sTUFBTW5CLFVBQVVDLGdCQUFnQkM7SUFFNUMsbUJBQW1CO0lBQ25CLE1BQU1rQixZQUFZLE1BQU1kLE9BQU9DLE1BQU0sQ0FBQ2MsT0FBTyxDQUMzQztRQUNFWCxNQUFNO1FBQ05RLElBQUlBO0lBQ04sR0FDQUMsS0FDQWhCLFFBQVFNLE1BQU0sQ0FBQ2EsS0FBS0MsU0FBUyxDQUFDUjtJQUdoQyxnQ0FBZ0M7SUFDaEMsT0FBTztRQUNMSyxXQUFXSSxvQkFBb0JKO1FBQy9CbEIsTUFB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aUIwRixNQUFNdkc7SUFFN0M7SUFFQSxPQUFPcUIsS0FBS0MsU0FBUyxDQUFDeUUsWUFBWSxNQUFNO0FBQzFDO0FBRUE7O0NBRUMsR0FDTSxlQUFlUyxnQkFDcEJDLFlBQW9CLEVBQ3BCekcsY0FBc0I7SUFFdEIsSUFBSTtRQUNGLE1BQU1jLE9BQU9PLEtBQUtVLEtBQUssQ0FBQzBFO1FBRXhCLElBQUksQ0FBQzNGLEtBQUtrRixPQUFPLElBQUksQ0FBQ2xGLEtBQUtnRixLQUFLLEVBQUU7WUFDaEMsTUFBTSxJQUFJWSxNQUFNO1FBQ2xCO1FBRUEsTUFBTVosUUFBUSxNQUFNTSxRQUFRQyxHQUFHLENBQzdCdkYsS0FBS2dGLEtBQUssQ0FBQ1EsR0FBRyxDQUFDLENBQUNLLGdCQUNkbkYsaUJBQWlCbUYsZUFBZTNHO1FBSXBDLE9BQU84RjtJQUNULEVBQUUsT0FBT2MsT0FBTztRQUNkLE1BQU0sSUFBSUYsTUFBTTtJQUNsQjtBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTRztJQUNkLE9BQU8sS0FBa0IsSUFDbEIsT0FBT0MsT0FBT3pHLE1BQU0sS0FBSyxlQUN6QixPQUFPeUcsT0FBT3pHLE1BQU0sQ0FBQ0MsTUFBTSxLQUFLO0FBQ3pDO0FBRUE7O0NBRUMsR0FDTSxTQUFTeUc7UUFBaUJuRyxTQUFBQSxpRUFBaUI7SUFDaEQsTUFBTW9HLFFBQVEsSUFBSWhHLFdBQVdKO0lBQzdCUCxPQUFPVSxlQUFlLENBQUNpRztJQUN2QixPQUFPeEMsTUFBTUMsSUFBSSxDQUFDdUMsT0FBT0MsQ0FBQUEsT0FBUUEsS0FBS0MsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHLE1BQU1uRSxJQUFJLENBQUM7QUFDNUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9jcnlwdG8udHM/NTBiZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmcm9udGVuZC9zcmMvbGliL2NyeXB0by50c1xyXG5cclxuLyoqXHJcbiAqIENsaWVudC1zaWRlIGVuY3J5cHRpb24gdXNpbmcgV2ViIENyeXB0byBBUElcclxuICogXHJcbiAqIEVuY3J5cHRpb24gU3RyYXRlZ3k6XHJcbiAqIC0gQUVTLUdDTSAyNTYtYml0IGVuY3J5cHRpb24gZm9yIHZhdWx0IGRhdGFcclxuICogLSBQQktERjIgd2l0aCAxMDAsMDAwIGl0ZXJhdGlvbnMgZm9yIGtleSBkZXJpdmF0aW9uXHJcbiAqIC0gUmFuZG9tIHNhbHQgYW5kIElWIGZvciBlYWNoIGVuY3J5cHRpb24gb3BlcmF0aW9uXHJcbiAqIC0gWmVyby1rbm93bGVkZ2UgYXJjaGl0ZWN0dXJlOiBzZXJ2ZXIgbmV2ZXIgc2VlcyBwbGFpbnRleHRcclxuICovXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEVuY3J5cHRlZERhdGEge1xyXG4gIGVuY3J5cHRlZDogc3RyaW5nOyAgLy8gQmFzZTY0IGVuY29kZWQgZW5jcnlwdGVkIGRhdGFcclxuICBzYWx0OiBzdHJpbmc7ICAgICAgIC8vIEJhc2U2NCBlbmNvZGVkIHNhbHRcclxuICBpdjogc3RyaW5nOyAgICAgICAgIC8vIEJhc2U2NCBlbmNvZGVkIGluaXRpYWxpemF0aW9uIHZlY3RvclxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFZhdWx0SXRlbSB7XHJcbiAgdGl0bGU6IHN0cmluZztcclxuICB1c2VybmFtZTogc3RyaW5nO1xyXG4gIHBhc3N3b3JkOiBzdHJpbmc7XHJcbiAgdXJsOiBzdHJpbmc7XHJcbiAgbm90ZXM6IHN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIERlcml2ZSBlbmNyeXB0aW9uIGtleSBmcm9tIG1hc3RlciBwYXNzd29yZCB1c2luZyBQQktERjJcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGRlcml2ZUtleShcclxuICBtYXN0ZXJQYXNzd29yZDogc3RyaW5nLFxyXG4gIHNhbHQ6IFVpbnQ4QXJyYXlcclxuKTogUHJvbWlzZTxDcnlwdG9LZXk+IHtcclxuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XHJcbiAgXHJcbiAgLy8gSW1wb3J0IHRoZSBtYXN0ZXIgcGFzc3dvcmQgYXMga2V5IG1hdGVyaWFsXHJcbiAgY29uc3Qga2V5TWF0ZXJpYWwgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcclxuICAgICdyYXcnLFxyXG4gICAgZW5jb2Rlci5lbmNvZGUobWFzdGVyUGFzc3dvcmQpLFxyXG4gICAgJ1BCS0RGMicsXHJcbiAgICBmYWxzZSxcclxuICAgIFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXVxyXG4gICk7XHJcbiAgXHJcbiAgLy8gRGVyaXZlIEFFUy1HQ00ga2V5IHVzaW5nIFBCS0RGMlxyXG4gIHJldHVybiBjcnlwdG8uc3VidGxlLmRlcml2ZUtleShcclxuICAgIHtcclxuICAgICAgbmFtZTogJ1BCS0RGMicsXHJcbiAgICAgIHNhbHQ6IHNhbHQsXHJcbiAgICAgIGl0ZXJhdGlvbnM6IDEwMDAwMCwgIC8vIEhpZ2ggaXRlcmF0aW9uIGNvdW50IGZvciBzZWN1cml0eVxyXG4gICAgICBoYXNoOiAnU0hBLTI1NidcclxuICAgIH0sXHJcbiAgICBrZXlNYXRlcmlhbCxcclxuICAgIHsgbmFtZTogJ0FFUy1HQ00nLCBsZW5ndGg6IDI1NiB9LFxyXG4gICAgdHJ1ZSxcclxuICAgIFsnZW5jcnlwdCcsICdkZWNyeXB0J11cclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogRW5jcnlwdCB2YXVsdCBpdGVtIGRhdGFcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNyeXB0VmF1bHRJdGVtKFxyXG4gIGRhdGE6IFZhdWx0SXRlbSxcclxuICBtYXN0ZXJQYXNzd29yZDogc3RyaW5nXHJcbik6IFByb21pc2U8RW5jcnlwdGVkRGF0YT4ge1xyXG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcclxuICBcclxuICAvLyBHZW5lcmF0ZSByYW5kb20gc2FsdCBhbmQgSVZcclxuICBjb25zdCBzYWx0ID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgxNikpO1xyXG4gIGNvbnN0IGl2ID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgxMikpO1xyXG4gIFxyXG4gIC8vIERlcml2ZSBlbmNyeXB0aW9uIGtleVxyXG4gIGNvbnN0IGtleSA9IGF3YWl0IGRlcml2ZUtleShtYXN0ZXJQYXNzd29yZCwgc2FsdCk7XHJcbiAgXHJcbiAgLy8gRW5jcnlwdCB0aGUgZGF0YVxyXG4gIGNvbnN0IGVuY3J5cHRlZCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZW5jcnlwdChcclxuICAgIHtcclxuICAgICAgbmFtZTogJ0FFUy1HQ00nLFxyXG4gICAgICBpdjogaXZcclxuICAgIH0sXHJcbiAgICBrZXksXHJcbiAgICBlbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeShkYXRhKSlcclxuICApO1xyXG4gIFxyXG4gIC8vIENvbnZlcnQgdG8gYmFzZTY0IGZvciBzdG9yYWdlXHJcbiAgcmV0dXJuIHtcclxuICAgIGVuY3J5cHRlZDogYXJyYXlCdWZmZXJUb0Jhc2U2NChlbmNyeXB0ZWQpLFxyXG4gICAgc2FsdDogYXJyYXlCdWZmZXJUb0Jhc2U2NChzYWx0KSxcclxuICAgIGl2OiBhcnJheUJ1ZmZlclRvQmFzZTY0KGl2KVxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWNyeXB0IHZhdWx0IGl0ZW0gZGF0YVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlY3J5cHRWYXVsdEl0ZW0oXHJcbiAgZW5jcnlwdGVkRGF0YTogRW5jcnlwdGVkRGF0YSxcclxuICBtYXN0ZXJQYXNzd29yZDogc3RyaW5nXHJcbik6IFByb21pc2U8VmF1bHRJdGVtPiB7XHJcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xyXG4gIFxyXG4gIC8vIENvbnZlcnQgZnJvbSBiYXNlNjRcclxuICBjb25zdCBzYWx0ID0gYmFzZTY0VG9BcnJheUJ1ZmZlcihlbmNyeXB0ZWREYXRhLnNhbHQpO1xyXG4gIGNvbnN0IGl2ID0gYmFzZTY0VG9BcnJheUJ1ZmZlcihlbmNyeXB0ZWREYXRhLml2KTtcclxuICBjb25zdCBlbmNyeXB0ZWQgPSBiYXNlNjRUb0FycmF5QnVmZmVyKGVuY3J5cHRlZERhdGEuZW5jcnlwdGVkKTtcclxuICBcclxuICAvLyBEZXJpdmUgZGVjcnlwdGlvbiBrZXlcclxuICBjb25zdCBrZXkgPSBhd2FpdCBkZXJpdmVLZXkobWFzdGVyUGFzc3dvcmQsIHNhbHQpO1xyXG4gIFxyXG4gIC8vIERlY3J5cHQgdGhlIGRhdGFcclxuICBjb25zdCBkZWNyeXB0ZWQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRlY3J5cHQoXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdBRVMtR0NNJyxcclxuICAgICAgaXY6IGl2XHJcbiAgICB9LFxyXG4gICAga2V5LFxyXG4gICAgZW5jcnlwdGVkXHJcbiAgKTtcclxuICBcclxuICAvLyBQYXJzZSBhbmQgcmV0dXJuIHRoZSBkYXRhXHJcbiAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2Rlci5kZWNvZGUoZGVjcnlwdGVkKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcmFuZG9tIHBhc3N3b3JkXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFBhc3N3b3JkT3B0aW9ucyB7XHJcbiAgbGVuZ3RoOiBudW1iZXI7XHJcbiAgaW5jbHVkZU51bWJlcnM6IGJvb2xlYW47XHJcbiAgaW5jbHVkZVN5bWJvbHM6IGJvb2xlYW47XHJcbiAgZXhjbHVkZUFtYmlndW91czogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlU2VjdXJlUGFzc3dvcmQob3B0aW9uczogUGFzc3dvcmRPcHRpb25zKTogc3RyaW5nIHtcclxuICBjb25zdCBsb3dlcmNhc2UgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xyXG4gIGNvbnN0IHVwcGVyY2FzZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWic7XHJcbiAgY29uc3QgbnVtYmVycyA9ICcwMTIzNDU2Nzg5JztcclxuICBjb25zdCBzeW1ib2xzID0gJyFAIyQlXiYqKClfKy09W117fXw7OiwuPD4/JztcclxuICBjb25zdCBhbWJpZ3VvdXMgPSAnaWwxTG8wTyc7XHJcbiAgXHJcbiAgLy8gQnVpbGQgY2hhcmFjdGVyIHNldFxyXG4gIGxldCBjaGFyc2V0ID0gbG93ZXJjYXNlICsgdXBwZXJjYXNlO1xyXG4gIGlmIChvcHRpb25zLmluY2x1ZGVOdW1iZXJzKSBjaGFyc2V0ICs9IG51bWJlcnM7XHJcbiAgaWYgKG9wdGlvbnMuaW5jbHVkZVN5bWJvbHMpIGNoYXJzZXQgKz0gc3ltYm9scztcclxuICBcclxuICAvLyBSZW1vdmUgYW1iaWd1b3VzIGNoYXJhY3RlcnMgaWYgcmVxdWVzdGVkXHJcbiAgaWYgKG9wdGlvbnMuZXhjbHVkZUFtYmlndW91cykge1xyXG4gICAgY2hhcnNldCA9IGNoYXJzZXQuc3BsaXQoJycpLmZpbHRlcihjID0+ICFhbWJpZ3VvdXMuaW5jbHVkZXMoYykpLmpvaW4oJycpO1xyXG4gIH1cclxuICBcclxuICAvLyBHZW5lcmF0ZSBwYXNzd29yZCB1c2luZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIGZvciBzZWN1cml0eVxyXG4gIGxldCBwYXNzd29yZCA9ICcnO1xyXG4gIGNvbnN0IHJhbmRvbVZhbHVlcyA9IG5ldyBVaW50MzJBcnJheShvcHRpb25zLmxlbmd0aCk7XHJcbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhyYW5kb21WYWx1ZXMpO1xyXG4gIFxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgcGFzc3dvcmQgKz0gY2hhcnNldFtyYW5kb21WYWx1ZXNbaV0gJSBjaGFyc2V0Lmxlbmd0aF07XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBwYXNzd29yZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhhc2ggcGFzc3dvcmQgZm9yIGF1dGhlbnRpY2F0aW9uIChjbGllbnQtc2lkZSBwcmUtaGFzaClcclxuICogTm90ZTogVGhpcyBpcyBOT1QgZm9yIHZhdWx0IGVuY3J5cHRpb24sIG9ubHkgZm9yIGF1dGhcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYXNoUGFzc3dvcmQocGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xyXG4gIGNvbnN0IGRhdGEgPSBlbmNvZGVyLmVuY29kZShwYXNzd29yZCk7XHJcbiAgY29uc3QgaGFzaCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgZGF0YSk7XHJcbiAgcmV0dXJuIGFycmF5QnVmZmVyVG9CYXNlNjQoaGFzaCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSBtYXN0ZXIgcGFzc3dvcmQgc3RyZW5ndGhcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVBhc3N3b3JkU3RyZW5ndGgocGFzc3dvcmQ6IHN0cmluZyk6IHtcclxuICBpc1ZhbGlkOiBib29sZWFuO1xyXG4gIGVycm9yczogc3RyaW5nW107XHJcbn0ge1xyXG4gIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcclxuICBcclxuICBpZiAocGFzc3dvcmQubGVuZ3RoIDwgMTIpIHtcclxuICAgIGVycm9ycy5wdXNoKCdQYXNzd29yZCBtdXN0IGJlIGF0IGxlYXN0IDEyIGNoYXJhY3RlcnMgbG9uZycpO1xyXG4gIH1cclxuICBpZiAoIS9bYS16XS8udGVzdChwYXNzd29yZCkpIHtcclxuICAgIGVycm9ycy5wdXNoKCdQYXNzd29yZCBtdXN0IGNvbnRhaW4gbG93ZXJjYXNlIGxldHRlcnMnKTtcclxuICB9XHJcbiAgaWYgKCEvW0EtWl0vLnRlc3QocGFzc3dvcmQpKSB7XHJcbiAgICBlcnJvcnMucHVzaCgnUGFzc3dvcmQgbXVzdCBjb250YWluIHVwcGVyY2FzZSBsZXR0ZXJzJyk7XHJcbiAgfVxyXG4gIGlmICghL1swLTldLy50ZXN0KHBhc3N3b3JkKSkge1xyXG4gICAgZXJyb3JzLnB1c2goJ1Bhc3N3b3JkIG11c3QgY29udGFpbiBudW1iZXJzJyk7XHJcbiAgfVxyXG4gIGlmICghL1teYS16QS1aMC05XS8udGVzdChwYXNzd29yZCkpIHtcclxuICAgIGVycm9ycy5wdXNoKCdQYXNzd29yZCBtdXN0IGNvbnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzJyk7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICBpc1ZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxyXG4gICAgZXJyb3JzXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb246IENvbnZlcnQgQXJyYXlCdWZmZXIgdG8gQmFzZTY0IHN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NChidWZmZXI6IEFycmF5QnVmZmVyIHwgQXJyYXlCdWZmZXJWaWV3KTogc3RyaW5nIHtcclxuICAvLyBOb3JtYWxpemUgdG8gVWludDhBcnJheSB2aWV3XHJcbiAgY29uc3QgYnl0ZXMgPSBidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclxyXG4gICAgPyBuZXcgVWludDhBcnJheShidWZmZXIpXHJcbiAgICA6IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XHJcblxyXG4gIGxldCBiaW5hcnkgPSAnJztcclxuICBjb25zdCBjaHVua1NpemUgPSAweDgwMDA7IC8vIHNhZmUgY2h1bmsgdG8gYXZvaWQgY2FsbCBzdGFjayBpc3N1ZXNcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcclxuICAgIGNvbnN0IGNodW5rID0gYnl0ZXMuc3ViYXJyYXkoaSwgaSArIGNodW5rU2l6ZSk7XHJcbiAgICBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBBcnJheS5mcm9tKGNodW5rKSk7XHJcbiAgfVxyXG4gIHJldHVybiBidG9hKGJpbmFyeSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9uOiBDb252ZXJ0IEJhc2U2NCBzdHJpbmcgdG8gVWludDhBcnJheVxyXG4gKi9cclxuZnVuY3Rpb24gYmFzZTY0VG9BcnJheUJ1ZmZlcihiYXNlNjQ6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xyXG4gIGNvbnN0IGJpbmFyeSA9IGF0b2IoYmFzZTY0KTtcclxuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeS5sZW5ndGgpO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBieXRlc1tpXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGkpO1xyXG4gIH1cclxuICByZXR1cm4gYnl0ZXM7XHJcbn1cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIGVuY3J5cHRpb24ga2V5IChmb3IgdGVzdGluZy9kZW1vIHB1cnBvc2VzKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tS2V5KCk6IFByb21pc2U8Q3J5cHRvS2V5PiB7XHJcbiAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZ2VuZXJhdGVLZXkoXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdBRVMtR0NNJyxcclxuICAgICAgbGVuZ3RoOiAyNTZcclxuICAgIH0sXHJcbiAgICB0cnVlLFxyXG4gICAgWydlbmNyeXB0JywgJ2RlY3J5cHQnXVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgcGFzc3dvcmQgZW50cm9weSAoYml0cyBvZiByYW5kb21uZXNzKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVBhc3N3b3JkRW50cm9weShwYXNzd29yZDogc3RyaW5nKTogbnVtYmVyIHtcclxuICBsZXQgY2hhcnNldFNpemUgPSAwO1xyXG4gIFxyXG4gIGlmICgvW2Etel0vLnRlc3QocGFzc3dvcmQpKSBjaGFyc2V0U2l6ZSArPSAyNjtcclxuICBpZiAoL1tBLVpdLy50ZXN0KHBhc3N3b3JkKSkgY2hhcnNldFNpemUgKz0gMjY7XHJcbiAgaWYgKC9bMC05XS8udGVzdChwYXNzd29yZCkpIGNoYXJzZXRTaXplICs9IDEwO1xyXG4gIGlmICgvW15hLXpBLVowLTldLy50ZXN0KHBhc3N3b3JkKSkgY2hhcnNldFNpemUgKz0gMzI7IC8vIEFwcHJveGltYXRlXHJcbiAgXHJcbiAgcmV0dXJuIE1hdGgubG9nMihNYXRoLnBvdyhjaGFyc2V0U2l6ZSwgcGFzc3dvcmQubGVuZ3RoKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFc3RpbWF0ZSB0aW1lIHRvIGNyYWNrIHBhc3N3b3JkIChpbiB5ZWFycylcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlc3RpbWF0ZVRpbWVUb0NyYWNrKHBhc3N3b3JkOiBzdHJpbmcpOiB7XHJcbiAgZW50cm9weTogbnVtYmVyO1xyXG4gIHRpbWVUb0NyYWNrOiBzdHJpbmc7XHJcbiAgc3RyZW5ndGg6ICdWZXJ5IFdlYWsnIHwgJ1dlYWsnIHwgJ01vZGVyYXRlJyB8ICdTdHJvbmcnIHwgJ1ZlcnkgU3Ryb25nJztcclxufSB7XHJcbiAgY29uc3QgZW50cm9weSA9IGNhbGN1bGF0ZVBhc3N3b3JkRW50cm9weShwYXNzd29yZCk7XHJcbiAgY29uc3QgZ3Vlc3Nlc1BlclNlY29uZCA9IDFlOTsgLy8gMSBiaWxsaW9uIGd1ZXNzZXMgcGVyIHNlY29uZFxyXG4gIGNvbnN0IHNlY29uZHNUb0NyYWNrID0gTWF0aC5wb3coMiwgZW50cm9weSkgLyBndWVzc2VzUGVyU2Vjb25kO1xyXG4gIGNvbnN0IHllYXJzVG9DcmFjayA9IHNlY29uZHNUb0NyYWNrIC8gKDM2NS4yNSAqIDI0ICogNjAgKiA2MCk7XHJcbiAgXHJcbiAgbGV0IHRpbWVUb0NyYWNrOiBzdHJpbmc7XHJcbiAgbGV0IHN0cmVuZ3RoOiAnVmVyeSBXZWFrJyB8ICdXZWFrJyB8ICdNb2RlcmF0ZScgfCAnU3Ryb25nJyB8ICdWZXJ5IFN0cm9uZyc7XHJcbiAgXHJcbiAgaWYgKHllYXJzVG9DcmFjayA8IDAuMDAxKSB7XHJcbiAgICB0aW1lVG9DcmFjayA9ICdJbnN0YW50bHknO1xyXG4gICAgc3RyZW5ndGggPSAnVmVyeSBXZWFrJztcclxuICB9IGVsc2UgaWYgKHllYXJzVG9DcmFjayA8IDEpIHtcclxuICAgIHRpbWVUb0NyYWNrID0gYCR7TWF0aC5yb3VuZCh5ZWFyc1RvQ3JhY2sgKiAzNjUpfSBkYXlzYDtcclxuICAgIHN0cmVuZ3RoID0gJ1dlYWsnO1xyXG4gIH0gZWxzZSBpZiAoeWVhcnNUb0NyYWNrIDwgMTAwMCkge1xyXG4gICAgdGltZVRvQ3JhY2sgPSBgJHtNYXRoLnJvdW5kKHllYXJzVG9DcmFjayl9IHllYXJzYDtcclxuICAgIHN0cmVuZ3RoID0gJ01vZGVyYXRlJztcclxuICB9IGVsc2UgaWYgKHllYXJzVG9DcmFjayA8IDEwMDAwMDApIHtcclxuICAgIHRpbWVUb0NyYWNrID0gYCR7TWF0aC5yb3VuZCh5ZWFyc1RvQ3JhY2sgLyAxMDAwKX1LIHllYXJzYDtcclxuICAgIHN0cmVuZ3RoID0gJ1N0cm9uZyc7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRpbWVUb0NyYWNrID0gYCR7TWF0aC5yb3VuZCh5ZWFyc1RvQ3JhY2sgLyAxMDAwMDAwKX1NIHllYXJzYDtcclxuICAgIHN0cmVuZ3RoID0gJ1ZlcnkgU3Ryb25nJztcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIGVudHJvcHk6IE1hdGgucm91bmQoZW50cm9weSksXHJcbiAgICB0aW1lVG9DcmFjayxcclxuICAgIHN0cmVuZ3RoXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEV4cG9ydCB2YXVsdCBkYXRhIChlbmNyeXB0ZWQpXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwb3J0VmF1bHREYXRhKFxyXG4gIGl0ZW1zOiBWYXVsdEl0ZW1bXSxcclxuICBtYXN0ZXJQYXNzd29yZDogc3RyaW5nXHJcbik6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgY29uc3QgZXhwb3J0RGF0YSA9IHtcclxuICAgIHZlcnNpb246IDEsXHJcbiAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIGl0ZW1zOiBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgICAgaXRlbXMubWFwKGl0ZW0gPT4gZW5jcnlwdFZhdWx0SXRlbShpdGVtLCBtYXN0ZXJQYXNzd29yZCkpXHJcbiAgICApXHJcbiAgfTtcclxuICBcclxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXhwb3J0RGF0YSwgbnVsbCwgMik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbXBvcnQgdmF1bHQgZGF0YSAoZGVjcnlwdClcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXBvcnRWYXVsdERhdGEoXHJcbiAgZXhwb3J0ZWREYXRhOiBzdHJpbmcsXHJcbiAgbWFzdGVyUGFzc3dvcmQ6IHN0cmluZ1xyXG4pOiBQcm9taXNlPFZhdWx0SXRlbVtdPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV4cG9ydGVkRGF0YSk7XHJcbiAgICBcclxuICAgIGlmICghZGF0YS52ZXJzaW9uIHx8ICFkYXRhLml0ZW1zKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBleHBvcnQgZmlsZSBmb3JtYXQnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgICAgZGF0YS5pdGVtcy5tYXAoKGVuY3J5cHRlZEl0ZW06IEVuY3J5cHRlZERhdGEpID0+IFxyXG4gICAgICAgIGRlY3J5cHRWYXVsdEl0ZW0oZW5jcnlwdGVkSXRlbSwgbWFzdGVyUGFzc3dvcmQpXHJcbiAgICAgIClcclxuICAgICk7XHJcbiAgICBcclxuICAgIHJldHVybiBpdGVtcztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gaW1wb3J0IHZhdWx0IGRhdGEuIENoZWNrIHlvdXIgbWFzdGVyIHBhc3N3b3JkLicpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIFdlYiBDcnlwdG8gQVBJIGlzIGF2YWlsYWJsZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQ3J5cHRvQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBcclxuICAgICAgICAgdHlwZW9mIHdpbmRvdy5jcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIFxyXG4gICAgICAgICB0eXBlb2Ygd2luZG93LmNyeXB0by5zdWJ0bGUgIT09ICd1bmRlZmluZWQnO1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgYSBzZWN1cmUgcmFuZG9tIElEXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTZWN1cmVJZChsZW5ndGg6IG51bWJlciA9IDE2KTogc3RyaW5nIHtcclxuICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XHJcbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSk7XHJcbiAgcmV0dXJuIEFycmF5LmZyb20oYXJyYXksIGJ5dGUgPT4gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyk7XHJcbn0iXSwibmFtZXMiOlsiZGVyaXZlS2V5IiwibWFzdGVyUGFzc3dvcmQiLCJzYWx0IiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwia2V5TWF0ZXJpYWwiLCJjcnlwdG8iLCJzdWJ0bGUiLCJpbXBvcnRLZXkiLCJlbmNvZGUiLCJuYW1lIiwiaXRlcmF0aW9ucyIsImhhc2giLCJsZW5ndGgiLCJlbmNyeXB0VmF1bHRJdGVtIiwiZGF0YSIsImdldFJhbmRvbVZhbHVlcyIsIlVpbnQ4QXJyYXkiLCJpdiIsImtleSIsImVuY3J5cHRlZCIsImVuY3J5cHQiLCJKU09OIiwic3RyaW5naWZ5IiwiYXJyYXlCdWZmZXJUb0Jhc2U2NCIsImRlY3J5cHRWYXVsdEl0ZW0iLCJlbmNyeXB0ZWREYXRhIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiYmFzZTY0VG9BcnJheUJ1ZmZlciIsImRlY3J5cHRlZCIsImRlY3J5cHQiLCJwYXJzZSIsImRlY29kZSIsImdlbmVyYXRlU2VjdXJlUGFzc3dvcmQiLCJvcHRpb25zIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIiwibnVtYmVycyIsInN5bWJvbHMiLCJhbWJpZ3VvdXMiLCJjaGFyc2V0IiwiaW5jbHVkZU51bWJlcnMiLCJpbmNsdWRlU3ltYm9scyIsImV4Y2x1ZGVBbWJpZ3VvdXMiLCJzcGxpdCIsImZpbHRlciIsImMiLCJpbmNsdWRlcyIsImpvaW4iLCJwYXNzd29yZCIsInJhbmRvbVZhbHVlcyIsIlVpbnQzMkFycmF5IiwiaSIsImhhc2hQYXNzd29yZCIsImRpZ2VzdCIsInZhbGlkYXRlUGFzc3dvcmRTdHJlbmd0aCIsImVycm9ycyIsInB1c2giLCJ0ZXN0IiwiaXNWYWxpZCIsImJ1ZmZlciIsImJ5dGVzIiwiQXJyYXlCdWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsImJpbmFyeSIsImNodW5rU2l6ZSIsImNodW5rIiwic3ViYXJyYXkiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsIkFycmF5IiwiZnJvbSIsImJ0b2EiLCJiYXNlNjQiLCJhdG9iIiwiY2hhckNvZGVBdCIsImdlbmVyYXRlUmFuZG9tS2V5IiwiZ2VuZXJhdGVLZXkiLCJjYWxjdWxhdGVQYXNzd29yZEVudHJvcHkiLCJjaGFyc2V0U2l6ZSIsIk1hdGgiLCJsb2cyIiwicG93IiwiZXN0aW1hdGVUaW1lVG9DcmFjayIsImVudHJvcHkiLCJndWVzc2VzUGVyU2Vjb25kIiwic2Vjb25kc1RvQ3JhY2siLCJ5ZWFyc1RvQ3JhY2siLCJ0aW1lVG9DcmFjayIsInN0cmVuZ3RoIiwicm91bmQiLCJleHBvcnRWYXVsdERhdGEiLCJpdGVtcyIsImV4cG9ydERhdGEiLCJ2ZXJzaW9uIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsIml0ZW0iLCJpbXBvcnRWYXVsdERhdGEiLCJleHBvcnRlZERhdGEiLCJFcnJvciIsImVuY3J5cHRlZEl0ZW0iLCJlcnJvciIsImlzQ3J5cHRvQXZhaWxhYmxlIiwid2luZG93IiwiZ2VuZXJhdGVTZWN1cmVJZCIsImFycmF5IiwiYnl0ZSIsInRvU3RyaW5nIiwicGFkU3RhcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/crypto.ts\n"));

/***/ })

});